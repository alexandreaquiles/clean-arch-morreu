1
00:00:00,462 --> 00:00:12,702
Mas é... Então vamos lá pessoal. Meu nome é Alexandre Aquiles.
Eu não vou falar onde eu trabalho, acho que vocês devem saber, né?

2
00:00:12,702 --> 00:00:26,222
Porque aqui o negócio é pra entre a gente mesmo, né?
Tipo... Então é papo nosso aqui mesmo. E aí entrou... Eu lancei um livro recentemente, né?

3
00:00:26,222 --> 00:00:39,494
Desbravando o Solid, deixa eu fazer o Jabá já, né?
desbravando o solid e aí eu fiz esse esse livro e no capítulo final assim né eu

4
00:00:39,494 --> 00:00:53,174
chego no marketeiro esagonal pelo menos eu acho que eu chego então vamos ver se
eu cheguei mesmo hoje a gente pode ser uma pauta mas aí a gente aí eu postei lá

5
00:00:53,174 --> 00:01:10,486
um twitter com um referenciando hipsters que
o Linhares e a Roberta Arco Verde e o Otávio Lemos e o Vinícius Dias e o Rodrigo Ferreira

6
00:01:10,486 --> 00:01:26,126
e o Paulo da Lura, eles estavam discutindo sobre Clean Architecture e aí repercutiu.
Então vários comentários, várias threads diferentes e tal.

7
00:01:26,894 --> 00:01:41,454
Então é sobre isso que a gente vai falar. E aí eu coloquei um título meio marqueteiro, né?
Clean Ark morreu. Até estava falando com o Anish, com o Linhares,

8
00:01:41,454 --> 00:01:51,234
que tipo, é para fazer uma referência àquele papo lá do
Istiridí Dad, né? Que teve entre o cara do Rails e o Kent Beck.

9
00:01:51,234 --> 00:01:57,038
Então é uma brincadeira, na verdade, né, pessoal?
Então, se a gente quiser falar assim, a CleanArch morreu,

10
00:01:57,038 --> 00:02:05,598
vamos falar que não e aí a gente pode fechar aqui.
Mas a brincadeira é a gente discutir um pouco sobre isso e tal.

11
00:02:06,318 --> 00:02:20,518
E aí eu queria que os oradores, aí eu vou chamando,
eu queria que vocês falassem o nome e... Definem uma frase assim, sabe?

12
00:02:21,178 --> 00:02:29,874
O que é CleanArchitecture? Então eu vou começar aí com o Linhares.
Vamos lá, Linhares. Manda abraço aí.

13
00:02:33,134 --> 00:02:48,334
Já, já tá querendo a confusão. Vamos começar.
Dessa vez eu vou roubar o que eu achei o comentário mais, que mais representa o que eu senti lendo

14
00:02:48,334 --> 00:02:55,094
o livro, é o comentário que o Anice fez no Twitter, que é conteúdo requentado.

15
00:03:02,958 --> 00:03:14,438
botou lá, né? Eu ainda fiquei sem entender o que efetivamente é a tal da Clean Architecture
que parece com tudo que a gente já viu antes, só que com coisas com nome diferente. Então

16
00:03:14,438 --> 00:03:28,518
eu tô meio confuso ainda. Boa. Vou na ordem aqui que tá aparecendo pra mim. Então, ô Branas, se apresenta aí
pra galera e tipo, o que é Clean Architecture em alguma frase assim?

17
00:03:28,518 --> 00:03:42,970
Ah, beleza cara. Bom, eu... sou só mais uma apaixonada por programação que tem um canal no YouTube e pra mim eu concordo
bastante com o que o Mauricio comentou, é um conteúdo sim um pouco, é uma mescla de

18
00:03:42,970 --> 00:03:55,370
óbvio superficial e requentado, mas de certa forma faz bastante sentido até a fronteira
com a camada de domínio que a gente vai discutir aqui hoje, então pra mim ele é um pouco

19
00:03:55,370 --> 00:04:06,382
um clone do Ports and Adapters e uma pitada de DDD.
mas por isso que eu acho ele superficial, mas depois eu entro um pouco mais nos detalhes.

20
00:04:06,382 --> 00:04:21,062
Certo, beleza. Aniche, você se apresenta e coloca uma definição sucinta,
eu sei que essas coisas não são para acadêmicos, mas vai lá.

21
00:04:24,430 --> 00:04:32,690
E aí, gente? Meu nome é Maurício. E definir clean architecture em uma frase é difícil, hein?
Mas acho que o que ele tentou naquele livro é mostrar

22
00:04:32,690 --> 00:04:40,490
como tentar criar aplicações que vão sobreviver ao tempo, né?
Que sejam fáceis de mudar, fáceis de evoluir, fáceis de testar.

23
00:04:40,490 --> 00:04:46,030
Se ele conseguiu isso no livro, é uma coisa que a gente vai discutir, né?
Mas acho que a ideia da clean architecture é essa.

24
00:04:46,030 --> 00:04:56,494
Certo. E o próximo que está aparecendo aqui, entrou aqui, é o ponte.
O Ponte, você nem sabe o que está acontecendo agora, né?

25
00:04:58,134 --> 00:05:05,214
E eu cheguei e peguei o bonde andando aqui, ouvi o comecinho, mas...
Não vou me repetir muito, né? Meu nome é Rafael Ponte, aqui.

26
00:05:05,614 --> 00:05:11,694
Conhecido como Marajá dos Legados, estão vindo a defender os legados.
Aham. Embora as pessoas não gostem, mas...

27
00:05:12,814 --> 00:05:20,946
Uma definição rápida de quem vem é artista, dado a minha pouca conhecimento, né?
Até o que eu estudo, é um excesso de camadas e de indireção.

28
00:05:21,038 --> 00:05:34,798
para abrindar meia dúzia de classes. Pronto, é assim que eu enxergo na maioria dos projetos que eu tenho visto.
Caramba, essa foi contundente. Eu senti um amago aí.

29
00:05:34,798 --> 00:05:52,190
Mas, Otávio, Otávio Lemos, beleza? Então, diga aí, se apresente e fale aí a sua definição.
Ah, eu esqueci de falar assim, tipo, faço seu jabasa aí também.

30
00:05:54,158 --> 00:06:14,158
Bom pessoal, meu nome é Otávio Lemos, eu sou professor universitário, sou professor da Universidade Federal de São Paulo há 13 anos.
E há três anos eu comecei um canal no YouTube, mais ou menos na mesma linha do Branas, falando sobre desenvolvimento de software, engenharia de software.

31
00:06:14,158 --> 00:06:29,150
E nessa mesma época que eu conheci essas ideias aí do Bob Martin.
Bom, pra mim é, de fato, me parece um... Ele mesmo fala isso, né? Que é um conjunto de ideias

32
00:06:29,150 --> 00:06:41,150
que foram se desenvolvendo sobre arquitetura de software no sentido de organização de código
e não de arquitetura de solução ou infra, né? Mas no sentido de design mesmo.

33
00:06:41,150 --> 00:06:55,366
Mas é um conjunto de ideias antigas, se a gente for ver, porque aparece lá no...
Ele fala do Ivar Jacobson lá. que é aquele desenvolvimento de software guiado por casos de uso.

34
00:06:55,966 --> 00:07:03,046
E depois tem outras abordagens como porting adapters
ou arquitetura hexagonal do Alastair Colburn.

35
00:07:03,526 --> 00:07:14,926
Então, assim, é um punhado de ideias. E me parece que o objetivo é esse.
Você ter uma arquitetura na qual você promove

36
00:07:15,526 --> 00:07:26,542
as suas regras de negócio e tenta desacoplá-las
de outros interesses do sistema. Claro que você pode abusar disso, qualquer tecnologia, qualquer abordagem você pode

37
00:07:26,542 --> 00:07:43,142
abusar e em vez de ser um benefício, ser uma coisa que vai te atrapalhar.
Certo. Eu vou chamar a Roberta, ela participou do podcast, do famoso podcast aí.

38
00:07:43,142 --> 00:07:55,534
Então Roberta, vou convidar você aqui. te coloquei aqui numa fria, numa rascada.
Mas eu tinha falado com a Roberta já, deixa eu ver aqui ó, com o vidar para falar.

39
00:07:55,534 --> 00:08:09,534
Ah, apareceu aqui. Pois é, clean art pra mim, de acordo também com o que o Otávio falou,
me parece uma parada que nem é clean nem é art, né?

40
00:08:09,534 --> 00:08:23,966
É design e não é clean no sentido de não ser simples, né?
No sentido de... de adicionar um pouco de complexidade para tentar definir abstrações e isolar interesses

41
00:08:23,966 --> 00:08:37,366
que, na minha opinião, sempre que se tenta isolar, o trade-off é que você abre mão
de coisas mais sofisticadas que você poderia estar utilizando e que informam o design do

42
00:08:37,366 --> 00:08:49,458
sistema. E abrir mão dessas coisas deliberadamente em nome de uma suposta flexibilidade para
a estrutura mude no futuro, para mim, sou um pouco inocente.

43
00:08:49,458 --> 00:08:59,250
Então, talvez seja a melhor forma que eu encontraria de definir
por tudo que eu li e que a gente tem discutido nesses dias.

44
00:09:01,294 --> 00:09:10,794
Beleza. Então só pra colocar uns termos que foram aparecendo aí,
tipo, tem muita essa coisa de ser algo antigo, né?

45
00:09:10,794 --> 00:09:22,274
Eu lembro de fazer coisa, diagrama OML, aí tinha o diagrama de robustez,
que tinha lá o Entidade, Controle e Boundary, né? O ECB.

46
00:09:22,274 --> 00:09:31,942
E, tipo, tá lá, o Otávio até falou aí do tal do Ivor Jacobson e era isso, né?
Tipo, vem lá do... do OML, inclusive eu acho que antes de existir o OML na verdade.

47
00:09:31,942 --> 00:09:54,142
Aí tem essa coisa de... Eu acho que a Roberta falou, o Ponte falou que talvez...
Muitas abstrações, muitas indireções. E eu acho que é isso que a Roberta falou, visa flexibilidade.

48
00:09:54,142 --> 00:10:06,354
Tanto o Otávio como a Roberta falaram aí de design.
Então talvez o nome arquitetura seja estranho, então arquitetura limpa, talvez seja um design limpo.

49
00:10:06,354 --> 00:10:22,934
E aí eu tava vendo aqui, tipo, tava lembrando, né, até coloquei um tweet lá de 2017 que eu tava bem radical, digamos.
E aí eu lembro que eu e o Rodrigo a gente tava querendo estudar sobre arquitetura.

50
00:10:22,934 --> 00:10:34,398
E aí tinham três livros que estavam sendo...
lançados. Um era o Building Evolutionary Architectures, lá em 2017.

51
00:10:34,398 --> 00:10:42,238
Que era da ThoughtWorks, que o Anish chegou a mencionar,
assim, tem um negócio de fitness function e tal.

52
00:10:42,238 --> 00:10:54,798
Eu não li, para falar a verdade. Aí tinha um que era o Designed, que é bem sobre arquitetura,
sobre trade-offs, estilos arquiteturais e tal, que era da Pragmatic Programmer.

53
00:10:54,798 --> 00:11:12,030
Só que ele não tinha arquitetura no nome. E tinha Clean Architecture que era sob design mas tinha arquitetura no nome.
E foi o que eu escolhi ler. E aí você pulou os dois melhores e pegou o pior.

54
00:11:14,950 --> 00:11:25,630
Mas aí eu fui tentar aplicar no Friula. Eu e um camarada de Android assim.
A gente estava querendo reaproveitar o modelo.

55
00:11:27,278 --> 00:11:42,078
Foi um desastre nesse caso específico. Porque eu acho que o modelo é diferente
de uma aplicação Android e da API, que é o que eu estava fazendo.

56
00:11:42,798 --> 00:11:52,998
E assim, eu não sofri muito porque o negócio não foi para frente.
Mas eu acho que eu teria sofrido. Aí, pessoal, o que eu queria

57
00:11:53,238 --> 00:12:04,734
é fazer uma brincadeira aqui do Olinhares. você ler o livro, vamos falar um pouco sobre o livro em si.
Só que eu quero, foi o Alan Silva que, eu não sei se ele está aqui,

58
00:12:04,734 --> 00:12:13,934
mas o Alan Silva que ele deu a ideia assim de,
o Linhares falou que ele achou de bom no livro.

59
00:12:13,934 --> 00:12:17,394
Então, destaque aí, Linhares, o que você achou de bom no livro.

60
00:12:21,326 --> 00:12:39,326
Bicho aí é difícil. Dá uma forçada aí, pensa um pouquinho.
É porque tem... Esse livro me levou para muitos momentos traumáticos do passado.

61
00:12:39,326 --> 00:12:50,098
Porque muito do que está sendo discutido, das coisas que estão sendo faladas,
são coisas que a gente queria matar ali no meio dos anos 2000, no Java.

62
00:12:50,318 --> 00:13:05,318
Você pega o livro do Rod Johnson, que foi o livro que deu nascimento ao Spring,
tem muito essa discussão de como era complicado você criar essa paração porque a gente tinha toda essa coisa de

63
00:13:05,318 --> 00:13:18,318
tudo tem um lugar, tem o Session Bean, tem o Entity Bean, tem um monte de Java Beans, a JB, essa porra toda.
E ele vem com essas ideias. Nesse livro, acho que esse é o livro do Rod Johnson.

64
00:13:19,086 --> 00:13:25,926
Ele tem muitas das ideias que a gente vê aqui
de você criar essa separação, de você não deixar o framework ficar dentro da sua aplicação,

65
00:13:25,926 --> 00:13:32,186
porque a gente sofria muito para escrever aplicações
e testar aplicações por causa do peso que o framework

66
00:13:32,186 --> 00:13:40,386
e as coisas do Java tinham em cima da sua plataforma.
E daí surge o Spring, e daí surge o jeito que a gente está escrevendo

67
00:13:40,386 --> 00:13:56,478
aplicações Enterprise em Java modernas. E eu acho que essa coisa de você separar...
é importante, né? Eu acho que isso, nisso ele acerta no livro que você realmente precisa separar

68
00:13:56,478 --> 00:14:10,558
essas coisas. Isso é uma coisa que a gente vem fazendo, assim, desde o primeiro livro de
modelagem design orientado a objetos que eu lembro de ter lido, que eu acho que é o de UML do

69
00:14:10,558 --> 00:14:24,770
Grady Bootsch, né? Que era um dos livros que eram recomendados pra gente na época da faculdade.
E era isso... E isso era uma recomendação, né? Que você não quer que essas coisas elas entrem dentro do seu código, né?

70
00:14:24,770 --> 00:14:35,530
Mas você não vai fazer isso de uma forma radical, né?
Como lá no teu tweet que eu coloco, ah, não quero nem botar as anotações no meu object.

71
00:14:35,530 --> 00:14:47,570
Aí você tá indo longe demais no negócio, né?
Porque a grande preocupação que a gente tinha na época não era de você ter referência ao framework, né?

72
00:14:47,982 --> 00:15:00,882
era como é que eu consigo testar e usar e fazer operações em cima dessas soluções
localmente na minha marca, fazer teste unitário, fazer TDD,

73
00:15:00,882 --> 00:15:10,522
você conseguir fazer o design da sua aplicação através dos testes,
e eu acho que essa eu vou dizer que é uma das poucas coisas que eu acho que são legais,

74
00:15:10,522 --> 00:15:19,346
mas o foda é porque ele é mais radical do que o seu tweet.
E é difícil de você separar essas coisas no livro.

75
00:15:19,346 --> 00:15:30,606
Eu tive muita dificuldade de pegar essas coisas e...
Ah, porra, isso aqui é importante. É muito importante a gente não deixar essas coisas vazarem para dentro de camadas

76
00:15:30,606 --> 00:15:39,066
para onde elas não deveriam ter vazado. Você tem que tentar separar essas coisas.
Eu acho que isso é uma mensagem que é importante,

77
00:15:39,066 --> 00:15:45,146
que é uma coisa que a gente repete em modelagem orientada ao objeto já,
provavelmente desde que existe modelagem...

78
00:15:46,062 --> 00:15:55,982
orientado a objetos. Mas... É interessante.
Mas olha como vai de experiência para experiência, né?

79
00:15:55,982 --> 00:16:02,582
Então, o meu primeiro contato com o trabalho dele foi naquele Agile Principles,
Practices and Patterns, alguma coisa assim, né?

80
00:16:02,902 --> 00:16:11,342
Foi antes do Clean Code, aliás. E eu vim... Eu estava vindo de três projetos na sequência.
Um deles, o primeiro, onde era uma loja virtual que a galera customizou,

81
00:16:11,342 --> 00:16:23,502
a loja virtual aberta em ASP da Local Web. quem lembra disso aqui, né? E eram aqueles arquivos ASP de 5 mil linhas, e tudo acontecia
ali. Aí eu pulei para um projeto na Sony, onde era o projeto que controlava a venda

82
00:16:23,502 --> 00:16:35,262
de DVDs da Sony, era tudo em JSP, e tudo na JSP. Aí eu fui trabalhar na Verifone, programar
em C, tudo num arquivo C completo. E aí, para mim, não fazia sentido, não é possível

83
00:16:35,262 --> 00:16:42,342
que não dava para ser melhor. E quando eu li aquele livro onde ele introduziu o Solid
pela primeira vez lá, etc. e tal, eu falei, porra, até que dá para separar as coisas,

84
00:16:42,342 --> 00:16:50,654
né? dá pra ser um pouquinho melhor, não precisa estar tudo no mesmo lugar.
Porque acho que a galera colocava, nos projetos que eu participei,

85
00:16:50,654 --> 00:16:55,534
estava tudo sempre no mesmo lugar. E pra mim foi um divisor de águas, ele dizia,
dá pra tentar modelar um pouquinho melhor.

86
00:16:56,734 --> 00:17:02,934
Agora, óbvio, ele é muito extremista na maneira de escrever.
Acho que é isso que você tem que ignorar quando lê.

87
00:17:02,934 --> 00:17:12,854
Eu falei em algum tweet disso, que se você for seguir a risca ali, o que ele fala, ele é bem extremista.
banco de dados é um detalhe, não sei em que mundo que banco de dados é um detalhe, né?

88
00:17:12,854 --> 00:17:26,298
Mas acho que pra mim foi isso que me agradou no trabalho dele lá, sei lá, em 2006, 2007,
quando eu comecei a ler o trabalho dele. Mas eu concordo em tudo que você comentou, Mauricio, que é muito extremista, né?

89
00:17:26,298 --> 00:17:37,338
Infelizmente é muito extremista, do meu ponto de vista, claro.
É, vai lá, Branc. Eu ia colocar só três pontinhos importantes aqui, tá?

90
00:17:37,338 --> 00:17:47,570
O primeiro ponto que eu acho que todo mundo concorda é que não faz sentido você misturar
o inbound driver, ou a inbound ports, se a gente pensar em ports e adapters,

91
00:17:47,822 --> 00:17:56,822
com regra de negócio, que é uma coisa que a gente sempre sofreu ao longo dos últimos 20, 30 anos, ou seja,
o teu controller tem regra de negócio, a tua tela tem regra de negócio,

92
00:17:56,822 --> 00:18:10,822
geralmente o controller é tela, mas se você tivesse um CLI, talvez ele pudesse ter regra de negócio,
talvez se você tivesse algum outro tipo de driver da aplicação, era muito comum que a gente presenciasse isso.

93
00:18:10,822 --> 00:18:19,618
Então o primeiro ponto-chave aqui do Clean Architecture é a camada de use cases, que seria...
aquela API da application que você expõe pra fora, certo?

94
00:18:19,618 --> 00:18:28,618
Então, acho que nesse ponto, ninguém discorda que isso é uma coisa super válida, né?
É a mesma proposta do Ilustrar Kubernetes, a mesma proposta do Ivara Jacobson,

95
00:18:28,618 --> 00:18:36,078
de muitos anos atrás também, e de qualquer um que
queira escrever uma aplicação que cresça e que tenha

96
00:18:36,078 --> 00:18:43,078
testabilidade e que possa ser conduzida de formas diferentes. Então,
nesse ponto aí, eu acho que o Client Architecture está perfeito nas colocações.

97
00:18:43,470 --> 00:18:50,350
Ele tem uma questãozinha em relação a Streaming Architecture,
que é sempre difícil você pensar naquele nome Service.

98
00:18:50,350 --> 00:18:58,070
E qual é o nome do Service? É Order Service, Client Service, Product Service.
Então, ele diz assim, olha, vamos criar um negócio chamado Use Case,

99
00:18:58,070 --> 00:19:03,570
que é a intenção exata do usuário, e a gente dá um nome,
então isso pode pulverizar uma grande quantidade de classes,

100
00:19:03,570 --> 00:19:10,310
mas até aí eu acho que está tudo bem. Para mim, a grande incongruência do Clean Architecture
está em um passo para dentro, não um passo para fora.

101
00:19:10,310 --> 00:19:22,218
Para fora... Tá tudo certo, separar frameworks e drivers, na minha visão, é inviável porque nem sempre os frameworks são intercambiáveis,
mas só o fato de você separar porta pra fora, porta pra dentro, já é uma coisa boa.

102
00:19:22,218 --> 00:19:32,958
O erro pra mim é na camada de entities, tá?
Rapidamente, só pra transmitir aqui a minha ideia, orientação objeto é uma coisa muito boa porque ela preserva variança.

103
00:19:32,958 --> 00:19:38,298
Basicamente esse é o objetivo da orientação objeto.
Não é simplesmente criar classe, porque você pode criar classe e continuar sendo procedural.

104
00:19:38,298 --> 00:19:46,430
Então você tem que... expor comportamento e preservar características
e assim você tem controle de invariância. Quando você tem um projeto muito orientado a um objeto,

105
00:19:46,430 --> 00:19:52,350
você tem uma relação entre os objetos. Então você começa a agrupar esses objetos em clusters.
Eles começam a ter referência uns pros outros.

106
00:19:52,350 --> 00:20:01,870
Esse é exatamente o conceito do aggregate que o Eric Evans traz em Domain Driven Design.
E o aggregate tem que ter um determinado tamanho

107
00:20:01,870 --> 00:20:06,578
pra que ele mantenha a consistência transacional
na hora de você fazer a persistência por meio de repositório.

108
00:20:07,182 --> 00:20:15,702
para que ele não seja nem muito grande e muito desengonçado
e ocupe muito espaço em memória e nem muito pequeno para que a granularidade seja tipo

109
00:20:15,702 --> 00:20:23,262
um mapeamento de tabela praticamente, né? Então uma linha tendo e difícil de obter.
E o Bob Martin não cita isso no livro dele.

110
00:20:23,262 --> 00:20:31,422
Tanto que quando eu vou... Eu tenho um curso sobre Clang Architects, não só sobre isso, né?
Sobre DDD, só e outras coisas. E eu sempre faço essa mescla.

111
00:20:31,422 --> 00:20:38,462
Então eu começo explicando. Pelo Portion Adapters...
traga o conceito de Clang Architecture e substitua a camada de entity

112
00:20:38,462 --> 00:20:46,062
por Domain Driven Design, mas aonde houver um domínio
suficientemente complexo que pague o custo disso?

113
00:20:46,062 --> 00:20:52,662
Porque se eu tenho uma aplicação muito simples, vai ser burocrático,
que é um pouco do que foi colocado por vocês logo no início.

114
00:20:52,662 --> 00:21:00,962
Então, para mim, esse é um tipo de design, um tipo de opção
que serve quando você tem um tipo de domínio mais complexo.

115
00:21:01,102 --> 00:21:07,362
Se você pensa na modulagem estratégica do domínio de design,
você separa uns domínios em subdomínios, uma pera e um contexto,

116
00:21:07,362 --> 00:21:15,742
e cada contexto é uma história diferente. Você pode adotar um scaffolding simples em um
e uma orientação a domínio super rica em outros usando DDD.

117
00:21:15,742 --> 00:21:24,962
Mas para mim, sempre aquela mescla de porcelain adapters e DDD,
ela é mais vencedora nesse caso. Clean Art fica meio que numa sombra disso.

118
00:21:24,962 --> 00:21:37,274
Esse é o meu ponto. Boa. Só queria... Vai lá, Otávio.
Só complementando essa ideia do Branas, eu acho legal quando você começa a perceber que, na verdade,

119
00:21:37,274 --> 00:21:49,314
tem a ver exatamente com isso que ele falou. Você não precisa usar todas as camadas para todos os seus casos de uso.
Inclusive, você pode ter alguns casos de uso mais simples, nos quais você só tem o próprio caso de uso,

120
00:21:49,314 --> 00:21:58,994
não entra mais para dentro. Eu acho que quando você começa a fazer essas adaptações para o seu contexto,
aí a coisa começa a fazer mais sentido. Então deixa eu fazer o jabá aqui.

121
00:21:59,118 --> 00:22:07,518
Eu acho que o meu livro é mais simples, né?
O meu livro, Arquitetura Limpa na Prática, ele resume as ideias e mostra um exemplo, né?

122
00:22:07,518 --> 00:22:16,038
E em 100 páginas lá você consegue pegar a essência da arquitetura limpa.
E é isso que o Brâncio falou também, eu acho interessante essa parte.

123
00:22:16,038 --> 00:22:22,238
Ninguém reclama de separar front-end e back-end.
Isso é uma coisa que a gente já faz faz muito tempo.

124
00:22:22,238 --> 00:22:33,490
Seria a parte esquerda da arquitetura hexagonal, ou port-scene adapters.
O galho fica quando você quer desacoplar coisas como banco de dados e tal,

125
00:22:33,490 --> 00:22:44,430
e aí já fica mais difícil de fazer e não faz sentido em todos os sistemas que você desenvolve.
Tem que ser adaptado ao seu contexto. Então acho que isso vale a pena a gente ter na cabeça, né?

126
00:22:44,430 --> 00:23:06,398
Que o Ancobob é muito enfático, né? Então você tem que colocar um filtro ali, não dá pra usar tudo aquilo que ele coloca em todos os sistemas,
tem que adaptar pro seu contexto. Sei. Eu acho que assim, a gente está assumindo que use case e vamos dizer,

127
00:23:06,398 --> 00:23:15,278
service, ou coisa do gênero, é uma unanimidade.
Agora, é de fato uma unanimidade entre nós aqui, pessoal?

128
00:23:15,278 --> 00:23:26,238
Eu não sei, por exemplo, a Roberta, eu acho que tem críticas, né, Roberta?
Isso dependendo do contexto, né? Qual seria esse contexto para você não usar esse tipo de...

129
00:23:26,990 --> 00:23:39,710
de organização de código. Que tipo de organização que você fala? Distribuído?
Tipo, assim, de separar a camada que está mais próxima

130
00:23:39,790 --> 00:23:45,790
da interface com o usuário do resto do sistema.
Porque eu lembro que a gente participou de um...

131
00:23:45,870 --> 00:23:55,430
Tem até um exemplo de um tweet lá que tinha até SQL
dentro de um controller, não tinha? Ah, não. Mas isso aí é um pouco indesculpável.

132
00:23:57,006 --> 00:24:19,670
Tá. Mas por que que... Por que aquilo? Eu acho que o foco da aplicação, quando a gente fala de clean arquiteto, de padrões, de modularidade,
é o que todo mundo quer, escrever uma aplicação que seja resiliente e fácil de manter a longo prazo.

133
00:24:19,670 --> 00:24:29,870
É isso que a gente quer dizer quando a gente fala de qualidade.
Ela é fácil de entender, ela é fácil de modificar, ela é fácil de manter em longo prazo.

134
00:24:29,870 --> 00:24:44,814
E tem... diversas técnicas e princípios e padrões para fazer isso que não necessariamente...
cujo modularidade não é necessariamente o único foco.

135
00:24:44,814 --> 00:24:59,614
Modularidade é um aspecto muito importante de monitorabilidade, mas não é um único.
Eu acho que quando você tem um Big Ball of Mud, ou seja, um sistema cuja arquitetura não pode sequer ser inferida

136
00:24:59,614 --> 00:25:29,618
porque ele é escrito de forma... completamente aleatórios e tem muitos padrões e é difícil de entender onde, se você vai escrever código novo, onde aquele código deve ficar, esse não é um mundo que ninguém quer estar.
Então eu gosto de divisões de camadas, eu acho que elas são importantes, eu acho que uma organização que permita com que o time de desenvolvimento, sempre que ele quiser alterar o código ou inserir uma nova funcionalidade, ele saia exatamente aonde esse código tem que entrar.

137
00:25:30,126 --> 00:25:40,566
Isso é desejável, isso é importante para a manutenibilidade de longo prazo.
Se você está falando de aplicação web que segue MVC, por exemplo,

138
00:25:41,126 --> 00:25:52,686
não é legal que você tenha acesso a dados no controlador exatamente por isso.
Agora, é catastrófico? Também não sei se é catastrófico, acho que depende muito, seja ou seja que não.

139
00:25:53,406 --> 00:26:02,714
Né? Se é um sistema muito pequeno, que não tem tantas alterações assim.
que nesse exemplo que eu dei era de um trecho de código que tava inalterado há sete anos,

140
00:26:02,714 --> 00:26:16,714
então nunca deu dor de cabeça pra ninguém. Então faz diferença realmente encaixar três ou quatro novas classes ali pra separar esses concerns?
Não acho que faça, sabe? Não acho que faça.

141
00:26:16,714 --> 00:26:27,406
Eu acho que a coisa que mais me incomoda é do tom desse livro e do tom desse autor.
é com o perdão do meu francês a cagação de regra mesmo, sabe?

142
00:26:27,406 --> 00:26:41,246
Parece que existe apenas uma forma de escrever esses temas, essa é a forma,
e quem faz assim tá correto, quem não faz assim tá fadado a escrever esses temas ruins, difíceis de manter.

143
00:26:41,246 --> 00:26:51,646
E é engraçado como comunidade como a gente aceita isso,
quando a gente também aceita um princípio que contradiz, isso que é o princípio de que não existe balde prata, né?

144
00:26:52,174 --> 00:27:05,694
É pouco controverso de que em design e arquitetura de software não existam soluções únicas,
que tudo depende, tudo de contexto, e ao mesmo tempo existe uma resistência a perceber que

145
00:27:05,694 --> 00:27:21,134
os designs propostos por Clean Architecture e pelo conjunto da obra do autor, sejam entendidos
como os únicos corretos, e que por exemplo, como o Maurício estava falando, como os dois Maurícios.

146
00:27:21,614 --> 00:27:34,374
estavam falando, seja interessante abstrair o seu banco de dados.
Ah não, é uma boa aplicação, bem feita, ela não deve se preocupar com qual é o mecanismo

147
00:27:34,374 --> 00:27:45,414
de storage, quando na verdade eu acho que isso complexifica e atrapalha a mantenibilidade,
ao invés de facilitar, porque a decisão de qual mecanismo de storage você vai usar

148
00:27:45,414 --> 00:27:57,978
é uma das mais importantes no planejamento de uma arquitetura.
E tentar torná-lo invisível traz mais problemas, na minha opinião, do que auxílios.

149
00:27:59,118 --> 00:28:06,318
Não sei se eu respondi a tua pergunta, Maís.
Sim, sim. É interessante esse questionamento.

150
00:28:06,318 --> 00:28:18,558
Tem bastante gente querendo falar aqui. Eu vou passar a palavra na ordem, assim, pro Ponte, pro Aniche, pro Linhares, pro Branas.
Beleza? Mas vai lá, Ponte. Show. Vou pegar aqui a tua pergunta, né?

151
00:28:19,086 --> 00:28:32,686
como é que a gente entende o que são use cases, né? Acho que o Lianyar comentou muito, né?
E de certa forma é algo até aberto, né? Mas para mim, acho que o Mauricio Anionchi, o Lianyar já...

152
00:28:32,686 --> 00:28:46,994
de muita data aí, mais de 10, 15 anos de experiência, a gente já sofreu demais com a ideia de gerar essas camadas de geração, né?
Use cases, a gente chama de service, a gente chama de manager. Então esse nome foi mudando com o tempo, né?

153
00:28:47,278 --> 00:28:54,498
Mas isso fazia muito sentido há 15 anos atrás,
talvez 10 anos atrás, eu falando aqui na plataforma Java, onde é o meu dia a dia,

154
00:28:55,618 --> 00:29:00,798
porque os frameworks não eram maduros o suficiente
para conseguir tirar todo aquele glue code,

155
00:29:00,818 --> 00:29:07,618
aquele código de infra que a gente era obrigado
a ter que implementar, escrever, ou copiar e colar de algum lugar.

156
00:29:08,078 --> 00:29:15,718
Só que isso mudou, isso mudou nos últimos, sei lá, talvez 10 anos para cá,
9, 8 anos para cá. que você pega uma plataforma como Spring,

157
00:29:15,758 --> 00:29:24,718
ou mesmo Java E, que hoje eu já cartei, e você consegue perceber que o controller que antes a gente temia
de deixar qualquer tipo de lógica de negócio,

158
00:29:24,758 --> 00:29:31,718
qualquer if, qualquer coisa relacionada ao nosso modelo de domínio,
hoje não tem mais esse problema. Hoje você pegar um controller do Spring

159
00:29:31,758 --> 00:29:40,038
basicamente é uma classe, um pojo, com algumas anotações.
E só. O controller está tão limpo, tão simples,

160
00:29:40,078 --> 00:29:45,298
onde o framework absorveu toda a complexidade,
o glue code que a gente... tentou evitar durante anos,

161
00:29:45,658 --> 00:29:54,098
que, para mim, na maioria dos casos, eu enxergo ele como meu use case.
E para muitas pessoas, isso é bem feio, porque

162
00:29:54,238 --> 00:30:02,758
se eu enxergo ele como use case, a chance são de que eu vou injetar um repositório,
um ou dois repositórios ali. E a ideia de que injetar repositório

163
00:30:02,938 --> 00:30:10,358
aproxima do banco de dados e está no controle
é ainda mais doloroso para muita gente. Mas se você pensar, a camada de persistência

164
00:30:10,398 --> 00:30:20,250
também foi abstraída pelos frameworks. um repositório de Spring Data, nada mais é do que uma interface
com algumas poucas anotações. E se você usa o JPAo e o JPAo Hibernate,

165
00:30:20,450 --> 00:30:25,950
então você tem uma camada de abstração com o Spring Data,
mas uma segunda camada um pouco mais funda que a JPAo Hibernate

166
00:30:25,970 --> 00:30:34,450
que abstra ainda mais a sua persistência, o JDBC e até um pouco o SQL ali.
Então qual é o problema de encarar o controle com o Musicase?

167
00:30:34,470 --> 00:30:40,610
Hoje, eu encaro ele com o Musicase até que algo me diga o contrário.
E geralmente o que me diz o contrário é...

168
00:30:41,010 --> 00:30:52,478
Tá fácil testar? Tá fácil entender? Eu consigo escrever um único teste aqui de integração
ou tenho que quebrar em vários testes para que isso fique mais fácil de testar,

169
00:30:52,478 --> 00:30:59,878
ter uma melhor cobertura e tudo mais? Então querendo ou não,
a manutenção é o que me guia junto com os testes.

170
00:30:59,878 --> 00:31:08,118
Então só para deixar claro, eu encaro que um controller
é sim uma camada de use case em qualquer literatura de arquitetura

171
00:31:08,118 --> 00:31:14,982
que alguém tenha lido aí. Essa é a minha percepção,
porque eu abraço... os frameworks que eu uso. A primeira regra que eu faço ao entrar em um

172
00:31:14,982 --> 00:31:24,662
projeto é abraçar o framework. Eu abraço framework e respeito o que ele me pede
para fazer. Em seguida eu abraço a linguagem de programação. Se a

173
00:31:24,662 --> 00:31:35,482
linguagem e o framework entram em conflitos, eu favoreço o framework, porque
eu vendi a minha alma para o Spring e eu quero os benefícios de ter

174
00:31:35,482 --> 00:31:45,030
medida minha alma para aquele da plataforma.
Hoje em dia eu estou muito nessa linha do ponte, mas o Anish, vai lá.

175
00:31:47,022 --> 00:31:54,822
Eu acho que a sacada é perceber isso mesmo que a Roberta e o Rafael comentaram,
porque se você olha para a aplicação Enterprise,

176
00:31:57,602 --> 00:32:06,302
como que ela funciona? De maneira bem abstrata, como que funciona basicamente
grande parte dos casos de uso? O usuário manda dado, você aumenta esse dado

177
00:32:06,322 --> 00:32:11,422
com a informação que você busca no banco de dados,
você faz umas varidações, você muda um pouquinho esse dado,

178
00:32:11,442 --> 00:32:18,230
você manda de volta para o banco de dados ou manda para um outro serviço web.
Uma grande parte das funcionalidades são isso.

179
00:32:18,230 --> 00:32:26,730
E para modelar esse tipo de coisa, você não precisa de coisa muito requintar, muito chique, entendeu?
Uma básica separação de responsabilidade, os repositórios do Spring aqui,

180
00:32:26,730 --> 00:32:34,310
põe uma varidaçãozinha se for um pouquinho complicado, um pouquinho ali, etc. e tal,
isso é mais o que o suficiente, né? Não precisa ir muito mais além.

181
00:32:34,310 --> 00:32:41,710
Eu acho que esse é o ponto, né? Mas aí tem sempre aqueles 20% de funcionalidade
que é muito mais complicado no teu sistema, que vai mudar o tempo inteiro,

182
00:32:41,710 --> 00:32:46,682
que regra nova entra, regra nova sai, etc. e tal.
talvez ali vale a pena um design mais robustado,

183
00:32:46,682 --> 00:32:53,362
e talvez algumas das ideias do livro dele façam sentido.
Mas acho que esse é o ponto, que a aplicação de indústria,

184
00:32:53,362 --> 00:32:59,402
uma grande parte das vezes, não precisa de tudo isso.
E o meu exemplo atual, eu trabalho na Adyen hoje,

185
00:32:59,402 --> 00:33:08,222
é uma base de código bem grande, um negócio bem complicado,
mas se você realmente quebra ele, é isso que eu falei,

186
00:33:08,222 --> 00:33:14,758
pega dado valido e passa o dado para frente, entendeu?
Não precisa de muito mais do que uma separação básica de responsabilidade.

187
00:33:18,478 --> 00:33:36,178
Perfeito. O Linhares. Vai lá. Então, aí é que eu acho que a superficialidade do livro atrapalha demais.
Porque a gente está chegando nesses exemplos mais complexos,

188
00:33:36,318 --> 00:33:52,630
só que o livro não abraça esses exemplos. Para você ter... É até esquisito pensar assim,
mas o único jeito de você... entender e pegar as ideias do Clean Architecture é se você tiver lido um monte de literatura anterior,

189
00:33:52,630 --> 00:34:00,790
se você tiver lido o Domain Driven Design, né, porque ele passa exatamente quatro parágrafos
definindo o que é entidades. São quatro parágrafos.

190
00:34:00,790 --> 00:34:10,770
Ele pega quatro parágrafos do livro e define o que é entidade.
E se você for ver o livro do Eric Evans, primeiro que entidade não é uma coisa só.

191
00:34:10,770 --> 00:34:18,870
Lá no Domain Driven Design, entidade é um pedaço.
da camada do modelo. Tem várias coisas que formam a camada do modelo.

192
00:34:18,870 --> 00:34:24,470
Tem uma definição específica para o que é uma entidade,
como é que você diferencia uma entidade de um velho object.

193
00:34:24,470 --> 00:34:33,750
Então tem várias coisas, tem várias discussões que o livro...
Eu não sei por que ele se furta. Eu não sei por que ele não para para explicar,

194
00:34:33,750 --> 00:34:40,630
porque a gente vai ter essa ideia que o Ponte falou,
que ele considera que os use cases é o controle.

195
00:34:40,630 --> 00:34:52,686
Que aí a gente vai entrar naquela discussão de boundaries, dos limites.
Mas ele não dá bons exemplos de limites. Cadê o padrão para dar os casos de limites que a gente tem?

196
00:34:52,686 --> 00:35:08,846
Mais uma vez a gente volta lá no Domain Driven Design, tem vários padrões diferentes e inclusive tem a opção que o Ponti está dizendo que é
Não faça nada, abrace o que está lá e use o modelo desse jeito.

197
00:35:10,830 --> 00:35:19,030
não ter nenhuma dessas discussões, não ter nenhum padrão,
não ter nenhuma discussão mais profunda sobre o que são essas coisas,

198
00:35:19,030 --> 00:35:28,530
como é que você usa essas coisas. Eu acho que empobrece muito o livro.
E se você já leu o Domain Driven Design, você não vai ter nada de novo desse livro.

199
00:35:28,530 --> 00:35:37,530
Porque as ideias, essa ideia de separação, essa ideia de você criar essas camadas,
de você ter o modelo, inclusive isso que o Anish falou.

200
00:35:37,742 --> 00:35:43,822
E às vezes seu modelo é só o banco de dados, e lá no Domain Data Design ele vai dizer,
às vezes é isso mesmo, é só o banco de dados.

201
00:35:43,822 --> 00:35:54,142
Você tá ali, por enquanto, você tá pobre, né?
Você não tem muita coisa pra colocar. Então, eu acho que essas discussões de definir os padrões, definir exemplos melhores, né?

202
00:35:54,142 --> 00:36:04,422
Eu achei os exemplos do livro também muito superficieis.
Tem um exemplo lá que me mandou direto pra o Java Enterprise Edition da Assam, né?

203
00:36:04,422 --> 00:36:14,858
Que é um livro lá de 2000, Guaraná de Rolha.
com múltiplas camadas de entrada e saída, e você não pode fazer a entidade vazar lá para a camada web,

204
00:36:14,858 --> 00:36:24,358
nem pode fazer a entidade vazar para a camada do banco de dados.
Então, eu acho que não ter uma discussão mais profunda

205
00:36:24,358 --> 00:36:33,398
sobre esses termos, sobre quem é entidade, o que é use case, com exemplos melhores,
com pattern, com padrões, mostrando os casos, onde é que você usa e...

206
00:36:33,582 --> 00:36:42,622
o gradiente que a gente está inserido na hora que a gente vai tomar uma decisão dessas
é uma coisa que, pra mim, empobreceu muito a leitura do livro.

207
00:36:42,622 --> 00:36:54,582
Eu entendo os conceitos porque eu li esses conceitos em outros lugares, mas no livro
é muito pouco, é uma discussão muito superficial e que é difícil de você tirar essas coisas

208
00:36:54,582 --> 00:37:09,630
de dentro deles se você não já consumiu muito material anterior.
Perfeito. Você mencionou aí o DDD, né? E eu lembro que eu tava conversando com o Hugo

209
00:37:09,630 --> 00:37:18,750
sobre qual a diferença entre hexagonal e clean architecture.
O hexagonal é nessa casca, ele não tem miolo, né?

210
00:37:18,750 --> 00:37:26,630
E aí o clean architecture tenta colocar um miolo,
só que muito superficialmente, né? E é exatamente o que o Branas tava falando, né?

211
00:37:26,630 --> 00:37:46,390
Que o DDD complementa aquilo, né, Branas? Eu concordo ali com o Mauricio nesse ponto. O Bob Marken, ele pegou literalmente carona na obra Clean Code,
que é uma excepcional obra no sentido de te mexer com o seu emocional, no sentido de trazer um pouco mais de ética para nossa profissão

212
00:37:46,390 --> 00:37:53,990
e se responsabilizar mais pelas ações, pelo código que a gente implementa.
Esse é o grande ponto do Clean Code, esse é o grande mérito dele, nada tão técnico.

213
00:37:53,990 --> 00:38:04,318
É mais um livro de autoajuda, não sei se muitos aqui concordam comigo, mas...
Clean Code é mais uma auto-ajuda e é muito bem-vindo do que propriamente um livro técnico, extremamente técnico.

214
00:38:04,318 --> 00:38:15,318
Clean Architecture pegou carona um pouco nessa fama do Clean, tanto que ele lançou também o Clean Craftsmanship,
o Clean Edge e outros Cleans que são bem menos interessantes.

215
00:38:15,318 --> 00:38:30,022
O Bob Martin não pôde trazer conceitos que ele deveria ter trazido por dois motivos.
O primeiro ele estaria copiando o DDB. O segundo, ele teria que escrever um livro três vezes maior.

216
00:38:30,022 --> 00:38:35,542
Como acho que o Mauricio falou, alguém falou,
DDD é um livro que tem mais ou menos 600 páginas.

217
00:38:35,542 --> 00:38:43,142
Você pega DDD, por exemplo, do Von Vernon, DDD do Steve Miller, que eu acho muito legal,
são livros extremamente grandes e que dá trabalho você definir.

218
00:38:43,142 --> 00:38:52,342
O que é um aggregate? O que é uma entity? O que é um velho objeto? O que é um repository?
É muito trabalho. E aí o Bob Marking, ele se resumiu a falar de um pattern chamado gateway.

219
00:38:52,342 --> 00:38:58,318
Vocês devem ter visto isso lá. O Gateway foi descrito pelo Martin Fowler,
no Patterns of Enterprise Application Architecture,

220
00:38:58,318 --> 00:39:05,618
que basicamente é uma abstração para um sistema externo.
Bom, banco de dados é um sistema externo. E ficou muito cru nesse sentido.

221
00:39:05,618 --> 00:39:16,738
Então, não é que é um erro, assim, né? O Bob pegou, literalmente, o blog post dele de 2012 e imprimiu.
É isso que o Mauricio citou, que tem quatro parágrafos falando sobre Entity.

222
00:39:16,738 --> 00:39:22,738
Então, ele não deixa muito claro o que ele quer com aquilo.
Agora, vamos pegar alguns ganchos aqui apenas, né?

223
00:39:23,950 --> 00:39:35,310
Ponto chave aqui. Não existe bala de prata, o que acho que a Roberta comentou,
there is no one size fits all. Não existe um tipo de design que vai servir para todos os casos,

224
00:39:35,310 --> 00:39:42,590
assim como não existe um pneu que vai ser bom na terra e no asfalto.
O pneu vai ter que dar pra caramba no asfalto e vai ser bom na terra,

225
00:39:42,590 --> 00:39:49,230
ou vai ser super rápido no asfalto, mas vai deslizar na terra.
Design é a mesma coisa. Então o que o Ponte colocou,

226
00:39:49,230 --> 00:40:04,918
ah, o meu controller, ele é... o meu use case e assim por diante, daí dali eu boto uma notation, já conecto de repente no meu ORM e já persisto.
Show! Mas isso por uma aplicação, por exemplo, de folha de pagamento ou de financiamento imobiliário,

227
00:40:04,918 --> 00:40:17,918
vai ficar aquendo do que poderia ser e aí que você tira grande proveito de Domain Driven Design,
de bounded context, de você entender quais são os aggregates, de você conseguir criar a preservação dessa invariância,

228
00:40:17,918 --> 00:40:26,422
que vai ser o que vai te dar. ter estabilidade no nível de unidade, que é uma coisa difícil,
se você encarar que tudo fica dando controller

229
00:40:26,422 --> 00:40:32,722
ou que tudo fica dando service, que é o que a gente costuma ver
em código extremamente procedural, escrito nos últimos 15, 20 anos,

230
00:40:32,722 --> 00:40:40,222
todo mundo aqui já deve ter passado por isso ou ainda vai passar.
Então, tem que separar os mundos. Quem tem uma aplicação simples, um crude,

231
00:40:40,222 --> 00:40:48,642
usa alguma coisa perto de um Rails, perto de um Django,
algo que te gere código e seja feliz. Agora, se você vai para uma aplicação complexa,

232
00:40:48,878 --> 00:40:59,738
Essas dependências, que é exatamente o D do SOLID, que o Alexandre escreveu o livro, inclusive,
falando sobre isso, que é High Level Modules Should Not Depend On Low Level Modules.

233
00:40:59,738 --> 00:41:07,178
É o fato de você não acoplar o teu SQL da tua regra de negócio.
E não é tão óbvio assim. A maior parte das pessoas faz isso.

234
00:41:07,178 --> 00:41:13,978
E qual é o problema? Qual é o drawback? Qual é o trade-off?
É que se você for testar, você vai ter que testar sempre no nível de integração.

235
00:41:13,978 --> 00:41:24,746
Não é questão de substituir o banco de dados.
A questão é você vai impor... ali uma necessidade de uso de test patterns, uso intenso de stubs, ou ter testes muito

236
00:41:24,746 --> 00:41:32,506
lentos ou desencorajar os testes e assim por diante.
Então assim, o trabalho do Bob Martin é bom no Clean Architecture?

237
00:41:32,506 --> 00:41:43,586
Definitivamente não. 99% das pessoas não leu o livro e comentam ou seguem somente a hype.
O trabalho dele é ruim. Posso dizer isso tendo lido, sei lá, dez vezes o que ele escreveu e tentando extrair

238
00:41:43,586 --> 00:41:50,110
ao máximo dos grupos de discussão que ele frequenta.
principalmente para tentar ver as respostas que todo mundo faz,

239
00:41:50,110 --> 00:41:58,390
as perguntas que todo mundo faz e que não são respondidas.
Por exemplo, um use case pode usar outro? E esse é um negócio que todo mundo pergunta, ele é evasivo na resposta.

240
00:41:58,390 --> 00:42:03,790
E aí você vai ver que o Domain Driven Design,
no Vomverno, principalmente, trazendo orientação a eventos,

241
00:42:03,790 --> 00:42:09,910
pegando uma ideia de even driven architecture,
e de você tentar desacoplar esses use cases

242
00:42:09,910 --> 00:42:17,806
e simplesmente publicar o evento, o fato que aconteceu,
e deixar o sistema reagir em cima disso. Isso gera desacoplamento, entende?

243
00:42:17,806 --> 00:42:25,686
Só que é para todo tipo de sistema? Claro que não.
Então, o trabalho do Bob é superficial. Ele não pode entrar em determinadas áreas,

244
00:42:25,686 --> 00:42:35,206
porque isso irá onerar demais o livro e aparecer que ele está copiando ainda mais.
Então, para mim, a grande sacada é, por serem adapters, eu não vejo como você abrir mão,

245
00:42:35,206 --> 00:42:42,606
seja uma aplicação pequena, seja uma aplicação grande,
porque senão você não tem testabilidade. Você não tem isolamento da aplicação

246
00:42:42,606 --> 00:42:50,750
e você está sempre preso... ou no mecanismo de entrada ou no dispositivo de I.O.
Então, pequeno ou grande, eu acho que esses conceitos são muito válidos.

247
00:42:50,750 --> 00:42:57,750
Orientação a domínio, vou puxar aqui mais o domínio de urban design,
é opção para projetos suficientemente complexos.

248
00:42:57,750 --> 00:43:04,750
E não só para projetos, vamos separar projetos de bounded context.
Subdomínio é uma coisa, projeto, empresa é outra.

249
00:43:04,750 --> 00:43:12,306
Você pode ter um bounded context de 10 que necessitam dessa abordagem.
Os outros 9 não. Então, eu acho que eu vou um pouco...

250
00:43:12,558 --> 00:43:28,898
nessa linha e só para fechar sobre o DTO, de novo a mesma coisa, entidade é uma coisa, tabela de banco de dados é outra,
estrutura de dado de entrada e saída é outra. Em aplicação simples esses conceitos são iguais,

251
00:43:28,898 --> 00:43:41,598
em aplicação complexa esses conceitos são diferentes. Valeu?
Beleza, vai lá Otávio. Boa, não só complementando os comentários que estão excelentes, né?

252
00:43:41,898 --> 00:43:49,998
Essa ideia do ponte de, quer dizer, faz tudo no controle, eu acho que
pode ter muitas aplicações em que isso é o melhor mesmo a fazer.

253
00:43:49,998 --> 00:43:58,798
E o mais legal ainda, eu acho que essa é a ideia que eu falei de adaptar, né?
Pode ser que numa mesma aplicação, para uma funcionalidade,

254
00:43:58,798 --> 00:44:07,770
basta você fazer tudo no controller, aquilo ali não vai atrapalhar.
Mas aí você tem um outro caso de uso mais complexo no qual aí tudo bem, você pode usar uma coisa mais sofisticada.

255
00:44:07,770 --> 00:44:21,250
Então eu acho legal também o sistema como uma coisa orgânica e na qual você pode adaptar e usar.
Eu acho legal essa ideia de porting adapters com padrão arquitetural que você pode usar os pontos da sua aplicação.

256
00:44:21,250 --> 00:44:30,590
Não precisa usar em todos os lugares. Você usa onde faz sentido.
Tem um cara também que é o Jimmy Bogard, que ele fala sobre isso, né? Ele fala sobre...

257
00:44:31,118 --> 00:44:49,118
você primeiro você faz por exemplo você faria tudo no controller e aí quando você começa a perceber as dores né você pode refatorar aquilo para melhorar eu acho isso uma visão bem positiva também em vez de você usar uma coisa mais prescritiva já de início já dividir as suas camadas

258
00:45:00,558 --> 00:45:06,078
no momento em que você começar a sentir a dor naquele ponto.
O segundo ponto que eu queria colocar é isso.

259
00:45:06,078 --> 00:45:14,718
Para mim, uma das maiores vantagens dessas ideias,
de Clean Architecture, arquitetura hexagonal,

260
00:45:14,718 --> 00:45:25,438
é você de fato poder testar as coisas de maneira separada.
Você poder testar suas regras de negócio sem se preocupar com o controller e tal.

261
00:45:25,438 --> 00:45:37,090
Então eu acho que isso é um ganho muito grande.
Eu queria só fazer um link, que o pessoal do mundo funcional já tem uma coisa bem parecida com ports and adapters e arquitetura hexagonal,

262
00:45:37,090 --> 00:45:51,650
que eles chamam lá de Imperative Shell Functional Core, que é a ideia de você ter um core funcional,
que é a parte do seu domínio, e aí ali você só tem funções puras, você pode testá-las de maneira separada também,

263
00:45:51,650 --> 00:46:08,886
e você empurra os side effects para as partes, para a parte mais externa da aplicação.
que tem a ver com essa ideia também. E aí seria comparável ao caso de uso, que no caso de uso você de fato conversaria com coisas externas.

264
00:46:08,886 --> 00:46:25,886
Então eu acho legal a gente ver também que essas ideias aparecem em vários lugares na comunidade e elas vão convergindo.
E óbvio que a gente tem que fazer esse trabalho de saber filtrar e saber usá-las da melhor maneira, adaptá-las para o nosso contexto.

265
00:46:28,014 --> 00:46:37,534
Aniche e Linhares, eu posso só... Para vocês comentarem em cima de um exemplo.
Então o Fernando Cruz, numa dessas threads,

266
00:46:37,554 --> 00:46:46,174
ele falou um negócio interessante. Falou assim, você vai fazer um sistema de pagamento
e vai ter que escolher adquirentes, fatores de decisão,

267
00:46:46,494 --> 00:46:58,350
aprovação do pagamento, taxas. Digamos que a Stony tenha taxa de 1,5% para qualquer bandeira,
uma aprovação de 70%. Uma aprovação meio ruim.

268
00:46:58,370 --> 00:47:09,530
A Cielo tem taxa de 4%, que é uma taxa meio ruim,
e aprovação de 95%. Então, ele colocou... Não tem nada a ver com a realidade aqui, pessoal.

269
00:47:09,550 --> 00:47:20,970
A Stone tem uma aprovação menor e a Cielo tem uma taxa maior.
Se você escolher... E aí ele fala disso. Ele comenta isso.

270
00:47:20,990 --> 00:47:29,542
E aí você pode integrar com as duas, seria uma solução.
usar a Stone como principal e fallback para Cielo.

271
00:47:30,262 --> 00:47:39,262
Nessa briga, aparece a rede com uma taxa de 1,5%
e aprovação de 97%. Então, a mesma taxa dá melhor

272
00:47:39,382 --> 00:47:45,782
e é uma aprovação muito melhor do que todas elas.
Uma arquitetura bem definida teria que ser extremamente fácil

273
00:47:45,802 --> 00:47:56,678
de mudar a adquirente que você vai usar sem precisar alterar todas as camadas.
Eu acho que aqui o lance é... Essa é uma coisa importante para o negócio, né?

274
00:47:56,698 --> 00:48:08,498
É uma opção que você quer deixar aberta. Então, eu acho que, assim, ao meu ver, a gente tem que ver.
Simplificar o que não traz tanta vantagem para o negócio

275
00:48:08,518 --> 00:48:17,278
e deixar flexível aqueles pontos que teriam vantagem para o negócio ser flexível.
Então, por exemplo, numa coisa de cursos online,

276
00:48:17,298 --> 00:48:30,354
por exemplo, a CDN que a gente vai integrar precisa ser flexível.
Isso é caso real mesmo? No meu caso lá, do meu exemplo do livro é, os formatos de ebook que vão ser gerados, eu quero que sejam flexíveis.

277
00:48:31,214 --> 00:48:49,570
Então, é, mas o Anishi, manda brasa aí. Nesse exemplo aí que você comentou, você já deu até a resposta?
Desculpa. O engraçado desse exemplo, Alexandre, quando você fala da CDN,

278
00:48:49,570 --> 00:48:56,050
na minha cabeça, nesse 1 segundo, CDN é uma coisa que você nunca vai mudar.
Quem que muda de CDN? Mas você acabou de falar que muda, né?

279
00:48:56,050 --> 00:49:07,310
É porque o custo é alto, sabe? É uma grande fonte de custo, sabe?
Então, você consegue uma eficiência melhor se você conseguir algo...

280
00:49:07,310 --> 00:49:15,406
É o mesmo exemplo aqui do caso das adquirentes, né?
Exato, e nesse ponto você precisa de flexibilidade, né? Então, por exemplo,

281
00:49:15,406 --> 00:49:22,606
a Adyen como Fintech, tenho certeza que na Stripe é a mesma coisa, adicionar um próximo adquirente
tem que ser fácil, certo? Porque é um negócio, né?

282
00:49:22,606 --> 00:49:32,046
Você quer invadir novos mercados, você precisa implementar os adquirentes daqueles mercados,
tem que ser fácil no sistema, né? Você não tem que fazer a pessoa abrir 400 classes

283
00:49:32,046 --> 00:49:44,470
para implementar um novo adquirente. Só que esse tipo de coisa, para ser honesto, é mais, acho que...
a exceção do que arrega nesse tipo de aplicação, porque a gente tem muito crude, como todos

284
00:49:44,470 --> 00:49:55,430
vocês já falaram. Um detalhe que eu queria comentar do livro, porque a galera estava
tweetando, eu estava lendo os tweets, e a gente comentou que o livro é opinionated,

285
00:49:55,430 --> 00:50:03,966
ele tem as decisões fortes ali e tal, acho que parte do trabalho nosso quando lê essas
coisas é... transferir para o nosso contexto, né?

286
00:50:03,986 --> 00:50:08,466
Esse trabalho que é mais de engenharia e não é tão científico, né?
A ideia é pegar mesmo e transferir para o nosso contexto.

287
00:50:08,486 --> 00:50:16,486
Aí eu me lembro, por exemplo, a gente está dando os exemplos do Evans sempre como positivos,
mas se você lembra lá o Guji, o.NET Architects em 2004, 2005,

288
00:50:16,506 --> 00:50:22,446
quando o livro saiu, a galera colava código fonte de classe ali e falava,
gente, isso aqui é um repositório de acordo com o Evans?

289
00:50:22,466 --> 00:50:29,906
Pouco importa, meu amigo, se o Evans acha que aquilo é um repositório.
Então, é difícil generalizar mesmo, né? Quando você lê um conteúdo novo e tal.

290
00:50:29,926 --> 00:50:35,894
É óbvio que o Evans escreveu isso muito melhor.
de uma maneira um pouco mais amigável, por isso que as pessoas não ficam tão putas com ele.

291
00:50:35,894 --> 00:50:46,494
O Anko Bob foi ali um pouquinho mais seco, né, na maneira de descrever.
Mas acho que esse é um... Acho que todo livro que a gente lê hoje, porque nós somos mais maduros e tal,

292
00:50:46,494 --> 00:50:54,214
você tem coisas que você não concorda em absoluto, né?
Acho que tem que dar esse, como fala em português, leap of faith, né?

293
00:50:54,214 --> 00:51:04,522
Você tem que dar um pouquinho ali de... um pouquinho de fé ali para o autor e deixar pular ali alguma coisa que você não concorda muito.
A única maneira de conseguir interpretar esses livros, eu acho.

294
00:51:06,762 --> 00:51:20,222
Isso me lembra muito o ciclo do hype, né? Que tipo, você tem aquela coisa de se empolgar e depois se ferra.
É natural. Isso acontece com ideias também de design de código.

295
00:51:20,222 --> 00:51:47,010
Mas vai lá, Olhinhares. Então aí, eu vou... Esse caso é um caso interessante porque quem trabalhou fazendo esse tipo de coisa sabe que toda vez que você vai integrar um adquirente novo, tem várias surpresas, né?
Que você não planejou lá na sua arquitetura, né? Vai ter modos de trabalho que são diferentes de todos os modos de trabalho que você tem.

296
00:51:47,010 --> 00:51:58,754
Tem gente que trabalha só mandando arquivo via FTP, tem gente que trabalha só via...
API web, tem gente que trabalha só via API, que você tem que alugar uma linha direta para esse cara,

297
00:51:58,754 --> 00:52:11,414
às vezes você tem que ter uma máquina fisicamente dentro do data center desse cara,
então tem um universo de coisas que você vai se surpreender quando você estiver fazendo integrações desse jeito.

298
00:52:11,414 --> 00:52:23,118
Então você vai criar esse modelo, e eu acho que é importante que as pessoas entendam que vocês vão fazer isso.
A minha crítica é que o livro não fala em hora nenhuma como é que você faz isso.

299
00:52:23,118 --> 00:52:39,198
A gente fala, fala, fala do Evans, eu vou até dizer, o livro é maior, são 600 páginas,
mas você vai tirar muito mais do livro do Evans do que você vai conseguir tirar mesmo arrancando o último suco do Clean Architecture.

300
00:52:39,198 --> 00:52:49,198
O conteúdo vai ser muito melhor, é chato, é um livro chato pra caralho, eu não vou dizer que é um livro legal de ler,
o Domain Design é um livro que é muito chato de ler.

301
00:52:49,486 --> 00:53:03,806
Mas você pode ler por pedaço, você pode ler os patterns que fazem mais sentido para você nesse momento, para você entender.
Então eu acho que vale mais a pena do que você ir atrás de ler o Plane Architecture.

302
00:53:03,806 --> 00:53:18,046
E eu acho que sim, tem recomendações que ele faz, umas recomendações meio enfáticas, que são ruins, são recomendações ruins.
Tá entendendo? Uma daqueles, daqueles faz é que, ah, dentro da sua equipe você vai fazer a distribuição...

303
00:53:18,350 --> 00:53:26,750
do seu domínio lá como um jar. Vai ser um jar separado, versionado,
que você vai pegar e você vai botar pra todo mundo.

304
00:53:26,750 --> 00:53:35,410
Então imagina numa empresa que tem lá mil desenvolvedores,
esses mil desenvolvedores formam 100 equipes diferentes

305
00:53:35,410 --> 00:53:43,390
e cada um produzindo as suas próprias bibliotecas.
Imagina o desespero que é você entender a matriz de dependência

306
00:53:43,390 --> 00:53:49,054
e que versão cada aplicação separada vai estar.
se você está distribuindo cada coisinha como um jar

307
00:53:49,054 --> 00:53:56,374
que a pessoa tem que atualizar a dependência
e mudar o número de versão. Isso é até uma das coisas que quando a gente foi fazer

308
00:53:56,374 --> 00:54:09,054
o API Gateway na Digital Ocean, a gente tomou a decisão de que não ia ter biblioteca,
não ia ter de jeito nenhum biblioteca, porque a gente não queria deixar isso como sendo uma dependência

309
00:54:09,054 --> 00:54:14,054
que todo mundo ia ter que ficar atualizando
porque a gente sabia que isso era terrível.

310
00:54:14,254 --> 00:54:18,934
o pessoal da SoundCloud teve essa experiência, não foi legal,
o pessoal do Twitter teve essa experiência, não foi legal,

311
00:54:18,934 --> 00:54:24,734
porque é muito difícil você fazer uma coisa dessas funcionar
quando você tem dependência de regra de negócio.

312
00:54:24,734 --> 00:54:30,434
Então, imagina que eu tenho um novo método de autenticação,
então, em vez de eu ter um lugar centralizado onde eu atualizo isso,

313
00:54:30,434 --> 00:54:38,814
agora eu tenho 50 aplicações diferentes, de equipes diferentes que vão todas ter que atualizar.
Imagina o pesadelo que é você fazer uma coisa dessas.

314
00:54:38,814 --> 00:54:45,650
Então, tem coisas realmente lá dentro que são, assim,
que você não deveria fazer. Você não deveria trabalhar desse jeito.

315
00:54:45,650 --> 00:54:58,790
Tem uma coisa que o Rodrigo falou que eu acho que precisa de deixar um pouco mais claro.
Não sei como o Rafael Freire não reclamou aí ainda que a aplicação Rails

316
00:54:58,790 --> 00:55:12,350
não é aplicação simples, minha gente. Shopify roda em Rails, o Stripe roda em Rails,
pegando pagamento do mundo todo, são aplicações complexas que dá pra você...

317
00:55:12,462 --> 00:55:24,862
Se você precisa, a gente volta para aquela coisa que o Rafael Ponte falou lá no início.
A vantagem é que você consegue fazer o simples e o complexo todos juntos.

318
00:55:24,862 --> 00:55:30,542
Não tem aplicação simples e aplicação complexa.
Tem pedaços simples e pedaços complexos dentro de uma aplicação.

319
00:55:30,542 --> 00:55:38,542
Então não é uma coisa que simplesmente, a minha aplicação é complexa porque é uma aplicação de pagamento.
Não é, bicho. Você vai ter lugares na sua aplicação onde é...

320
00:55:38,670 --> 00:55:46,150
complexo, onde fazer o que o Ponte falou, meter tudo dentro do controller.
Não vai ficar legal, porque você é muito código,

321
00:55:46,150 --> 00:55:51,630
porque você precisa reusar esse código em algum outro serviço,
em algum outro lugar, então você vai conseguir separar isso aí,

322
00:55:51,630 --> 00:55:59,950
ou você pode simplesmente botar dentro do controller.
E esse foi, pelo menos para mim, lá em 2006, 2007,

323
00:55:59,950 --> 00:56:07,230
o pulo do gato, quando eu comecei a trabalhar com Rails,
depois de sair do Java, e ver que, porra, eu não preciso de toda essa complicação, se eu posso...

324
00:56:07,406 --> 00:56:14,366
Se eu tenho casos que são mais simples, eu posso fazer simples aqui.
E se eu tenho casos que são mais complexos, eu posso criar um modelo separado,

325
00:56:14,366 --> 00:56:23,906
posso criar um serviço, posso deixar essa complexidade aonde ela está.
Então, não é porque você está trabalhando com Rails, com Django, com PHP,

326
00:56:23,906 --> 00:56:27,866
que você só está escrevendo a aplicação simples,
e você só pode escrever a aplicação simples.

327
00:56:27,866 --> 00:56:34,066
Você pode escrever, muita gente escreve, muita gente deu muito certo
escrevendo aplicações complexas usando essas ferramentas aí.

328
00:56:35,566 --> 00:56:46,546
Deixa eu pular a fila rapidinho aqui para reforçar uma coisa que o Mauricio falou, que eu acho que é o principal desafio na prática.
Que você criou sua abstração linda, maravilhosa, a próxima implementação vai ser diferente, entendeu?

329
00:56:46,546 --> 00:56:57,446
Vai ter alguma coisa para mudar. Eu acho que no hipster, que o pessoal gravou com a Adyen, o pessoal, o Tefe brincou, né?
Que quando foi implementar o primeiro meio de pagamento brasileiro, parcelamento.

330
00:56:57,446 --> 00:57:03,726
Ninguém parcela, os gringos aqui não entendiam que era parcelamento, né?
Então a abstração que tinha para adquirente não funcionava.

331
00:57:03,982 --> 00:57:09,982
sempre a próxima implementação vai ser um pouco diferente.
E aí que entra o desafio, como que você continua evoluindo

332
00:57:09,982 --> 00:57:17,982
essa abstração de maneira legal sem começar a poluir ela e deixar estragar?
Acho que esse é o desafio cruel, que esses livros não tocam tanto.

333
00:57:17,982 --> 00:57:21,982
Nos exemplinhos, obviamente, eles têm que simplificar,
porque senão eles vão escrever um livro de 5 mil páginas,

334
00:57:21,982 --> 00:57:28,482
mas como que você modifica sua abstração para entender
essas pequenas diferenças que elas sempre acabam acontecendo?

335
00:57:28,482 --> 00:57:41,146
Acho que essa é a chave no mundo real. Pois é, nada como o mundo real para destruir a sua abstração.
Mas vai lá, Baranço. Não, o senhor é repostar uma coisa, até em cima do que o Mauricio falou.

336
00:57:41,146 --> 00:57:52,266
Eu me referi, unique exclusivamente, ao processo de scaffolding padrão, tá?
Uma linguagem de programação, seja ela qual for, desde que ela tenha o devido suporte ao que você precisa fazer,

337
00:57:52,266 --> 00:58:00,266
você tem a capacidade de comunicar o computador e orientar para aquele processo aquilo que você precisa.
Não existe qualquer limitação, isso eu falo em...

338
00:58:01,262 --> 00:58:12,702
todos os momentos que eu posso em que não tem absolutamente nada a ver uma linguagem como PHP, Ruby, Python, Java
com o propósito ao qual você a utiliza salvo por questões de performance e alguma outra implicação, tá?

339
00:58:12,702 --> 00:58:27,022
Então, longe de mim ter afirmado alguma coisa nesse sentido, me referir aos scaffolding, especificamente a olhar isso como padrão
e quando você começa a ter mais regras de negócio, o que vai acontecer aqui é um jogo de pros e contras, única e exclusivamente.

340
00:58:27,022 --> 00:58:34,174
O que o Alexandre comentou em relação aos adquirentes...
Eu já implementei muita aplicação com adquirentes, com 10, 15 adquirentes.

341
00:58:34,174 --> 00:58:45,254
E a ideia ali é, eu posso levar esse código de uma forma mais procedural
e ter uma classe, ou ter um arquivo muito grande, cheio de fielse que hora faz um adquirente,

342
00:58:45,254 --> 00:58:51,254
hora faz outro? Posso. Qual é o problema disso?
Vai funcionar? Vai. Mas eu vou mexer muito nesse mesmo arquivo.

343
00:58:51,254 --> 00:58:59,254
Eu vou ter um acoplamento um pouco maior com a tecnologia e eu eventualmente vou fragilizar.
Agora eu posso usar um padrão como um adapter, inverter a dependência, isolar essa implementação?

344
00:58:59,374 --> 00:59:09,294
e definir um contrato que sirva para 90% deles ou 100% deles, pode?
Pode acontecer, como o Mauricio falou, deles serem tão radicalmente diferentes ao ponto desse contrato sem-válido?

345
00:59:09,294 --> 00:59:14,774
Pode. Se não der, não deu. Faz de outra forma, entendeu?
Então, o tempo todo aqui é bounded context.

346
00:59:14,774 --> 00:59:23,934
O que o Mauricio se refere à aplicação tem partes simples e partes complexas.
Na verdade, o domínio é decomposto em subdomínios simples e complexos.

347
00:59:24,174 --> 00:59:33,234
os complexos, você pode tomar uma decisão de fazer de um jeito, os simples de outro,
você pode fazer todos do mesmo jeito e ora ter uma manutenibilidade pior,

348
00:59:33,234 --> 00:59:38,874
ora ter melhor, a decisão é de cada um, sabe?
Funcionar, uma coisa eu garanto, tudo vai funcionar.

349
00:59:38,874 --> 00:59:42,254
A questão é em que condições vai funcionar, só isso.

350
00:59:46,862 --> 00:59:53,822
Boa! Puxa aí, Ponte! Deu uma distraída aqui, foi mal.
Ah, não, legal, legal. Eu vou aproveitar que o Gancho do Maurício, né?

351
00:59:53,822 --> 01:00:03,502
Que ele falou sobre... sobre domínios complexos, né?
A gente costuma falar, não, você usa esse DDD, você usa clean, você usa hexanal,

352
01:00:03,502 --> 01:00:12,422
você tem um domínio complexo, você tem um sistema complexo, mas isso é tão subjetivo,
o que significa? Até hoje eu tenho uma dúvida do que eu considero complexo,

353
01:00:12,422 --> 01:00:18,646
um domínio complexo, um sistema complexo, algo do tipo, tá?
E aí talvez porque eu venho muito do mundo corporativo, né?

354
01:00:18,646 --> 01:00:26,206
E aí é onde a Anish até comentou. A gente vive de crude, né?
Então ali 80% ou mais ali é o bom e velho crude

355
01:00:26,206 --> 01:00:35,906
e talvez um relatóriozinho ali em PDF bonitinho, o 1.csv.
Mas aí a pergunta que fica é o que é o mundo muito complexo?

356
01:00:36,106 --> 01:00:42,146
Então eu acho que o Brando já te comentou, né?
Então eu devo ter muito claro as minhas portas na adapters,

357
01:00:42,146 --> 01:00:48,150
adapters, os drivers, tudo ali. Quando eu tenho um domínio complexo, eu quero separar,
eu quero testar, especialmente teste de unidade,

358
01:00:48,210 --> 01:00:55,710
acho que ele comentou até isso. E eu interrogo, vamos que é complexo.
Crude é complexo? Eu acho que não, mas 80% dos sistemas corporativos são crudes.

359
01:00:55,890 --> 01:01:01,910
Microsserviços é complexo? Se você pensar numa aplicação como toda,
adaptando microserviços, sim, ela é complexa,

360
01:01:02,450 --> 01:01:09,910
mas o microserviço não é complexa na base de código,
ela é complexa nas bordas, na comunicação.

361
01:01:09,990 --> 01:01:16,550
Então, o microserviço tirou toda a complexidade
que o desenvolvedor tinha que manter numa base de código com dezenas de milhares de linhas

362
01:01:16,990 --> 01:01:22,630
e fez o desenvolvedor manter apenas algumas poucas
centenas ou milhares de linhas, pouquíssimas linhas,

363
01:01:22,670 --> 01:01:30,150
pouquíssimas classes e jogou a complexidade nas bordas.
Então o microserviço está nas bordas. Mas se o microserviço me deu o luxo, a palavra luxo aqui

364
01:01:30,510 --> 01:01:38,350
de ter um código mais simples, uma base de código mais simples,
por que eu não abraço isso? Porque se eu tenho um código mais simples,

365
01:01:38,510 --> 01:01:43,110
vamos pensar, o microserviço me permite criar
uma funcionalidade, um componente que tem uma...

366
01:01:43,278 --> 01:01:50,638
responsabilidade bem definida. Responsabilidade bem definida quer dizer que
tudo que ocorre ali está tudo intimamente ligado.

367
01:01:50,638 --> 01:01:58,678
Eles têm um fortíssimo acoplamento porque tudo mexe com o mesmo contexto.
Se mexe o mesmo contexto, para que eu tenho que criar única massa de indireção

368
01:01:58,678 --> 01:02:07,358
para separar as coisas? E se está tudo íntimo e a complexidade está nas bordas,
que geralmente é o que você vê, este distribuído está na entrada e na saída,

369
01:02:07,358 --> 01:02:11,838
querendo ou não, eu vou ter esse acontuamento com as bordas.
Eu tenho que saber qual o protocolo de entrada.

370
01:02:11,950 --> 01:02:17,910
e tem que saber de alguma forma qual protocolo de saída.
Até porque as regras de negócio, que a gente chama a lógica de negócio,

371
01:02:17,950 --> 01:02:23,830
ela não está em um único ponto na aplicação,
ela está espalhada por toda a aplicação. Desde de como vai entrar,

372
01:02:23,870 --> 01:02:31,870
se aquilo ali vai, qual tipo de protocolo de entrada, de tipagem,
até o banco de dados. Quando eu falo banco de dados, estou falando que boa parte

373
01:02:31,910 --> 01:02:37,550
da minha lógica de negócio vão estar em como eu definir meu esquema,
como é que eu defini os tipos, como é que eu defini as constrantes.

374
01:02:37,590 --> 01:02:47,262
A concorrência, ignorar isso é dar um tiro no pé.
E aí o Bruno até falou, ah, mas aproveita a vantagem de portos e adapters

375
01:02:47,262 --> 01:02:52,062
nesse domínio complexo, é que eu escrevo mais teste de unidade.
Mas se eu estou dentro do contexto de microserviços,

376
01:02:52,062 --> 01:02:57,322
vamos se amarrar ao contexto de microserviços aqui,
até para não generalizar, onde a complexidade está nas bordas,

377
01:02:57,322 --> 01:03:07,262
está na comunicação remota, é burrice, desculpa a palavra,
é burrice ignorar isso. Por isso, teste de integração, na minha opinião,

378
01:03:07,262 --> 01:03:15,486
faz muito mais sentido quando eu trabalho com microserviços.
Por dois motivos. Eu vou sempre exercitar as bordas, que é onde está a complexidade,

379
01:03:15,526 --> 01:03:23,426
provavelmente a maioria dos bugs. Eu tenho pouquíssima regra de negócio a nível de código de aplicação,
porque eu tenho um domínio, um subdomínio,

380
01:03:23,486 --> 01:03:30,586
uma quantidade de código muito acoplada, muito íntimo,
e que pouca coisa faz. Então, eu só queria deixar claro que tipo...

381
01:03:31,386 --> 01:03:38,086
Domínios complexos é difícil definir, mas dado que eu estou num contexto de microserviço
onde eu tenho pouco código, eu tenho o luxo de ter pouco código,

382
01:03:38,146 --> 01:03:47,190
então eu deveria abraçar. Abraçar significa diminuir as camadas de direção,
abraçar o framework, entender que estou em uma comunicação remota

383
01:03:47,270 --> 01:03:52,950
e que testes de integração acabam sendo muito melhores
para a manutenção e para a vida útil do sistema.

384
01:03:53,030 --> 01:03:55,310
Só deixando claro que é minha opinião.

385
01:03:58,414 --> 01:04:12,274
Otávio, quer comentar? É só um comentário, eu achei interessante você trazer o assunto de microserviço,
porque eu acho que é bem característico, uma coisa que se a pessoa não souber fazer direito,

386
01:04:12,274 --> 01:04:26,514
faz muita cagada, né? Então, eu acho interessante você ter isso sempre em mente.
Otávio, deixa só comentar aqui, tipo, um ano antes talvez desse freela que eu fiz...

387
01:04:26,574 --> 01:04:42,934
aí usando esse esquema do xml para mapear a entidade e tal, tinha um colega que fez
um freela com microserviços de atendimento de dentista, não sei lá, foi muito mais

388
01:04:42,934 --> 01:04:54,734
desastroso assim e esse realmente o cliente quis e deu certo, sabe?
E foi o terror da manutenção. Só um detalhe.

389
01:04:56,046 --> 01:05:02,926
Não, é só isso que eu estava querendo complementar.
E eu acho que é bom a gente sempre deixar isso claro.

390
01:05:02,926 --> 01:05:10,206
Para você obter benefícios desse tipo de técnica e abordagem,
você tem que estudar o negócio, saber usar.

391
01:05:10,206 --> 01:05:19,246
Porque senão você vai se ferrar. Por melhor que seja a ideia, por melhor que seja a tecnologia.
Eu conheço, por exemplo, gente que tem muita experiência com microserviços.

392
01:05:19,246 --> 01:05:32,226
Tem sempre essa ideia, começa com monolid, depois quebra para microserviços.
Não cara, se o cara manja, se o pessoal já teve um monte, já fez um monte de sistema baseado no microserviço, já tem experiência, o contexto casa com o uso de microserviço,

393
01:05:32,226 --> 01:05:51,466
o cara pode começar e ter muito sucesso. Então, mas é isso, eu só queria enfatizar isso, é que a pessoa, o pessoal tem que dominar essas técnicas, essas ideias para poder aplicar bem,
que senão você vai dar um tiro no pé. Perfeito. O Linhares, vai lá.

394
01:05:52,646 --> 01:05:58,606
Vamos voltar para o caso das adquirentes, né?
Que a interface, no geral, ela tem duas coisas.

395
01:05:58,626 --> 01:06:08,286
Ela tem um predicado, né? Que é para verificar se essa transação é específica, né?
Se essa adquirente vai ser capaz de processar essa transação.

396
01:06:08,306 --> 01:06:16,346
Então, tem várias informações que você vai usar.
Você vai usar o tipo do dinheiro, né? Você está usando real, está usando dólar, isso aí influencia...

397
01:06:16,526 --> 01:06:25,126
a decisão qual país do cartão, o país emitido do cartão,
se é cartão internacional ou não. Então, a gente tem esse predicado que define qual vai ser executada

398
01:06:25,126 --> 01:06:34,326
e a gente tem a implementação da execução mesmo do negócio,
que é aquele padrão estratégia que a gente está acostumado.

399
01:06:34,326 --> 01:06:43,926
Esse problema do adquirente é o problema de roteamento
que você tem numa aplicação web. Então, esse problema...

400
01:06:44,142 --> 01:06:56,462
Esse problema em si, ele é complexo? É, porque...
Parece fácil de entender, assim. É, ele é um problema que ele é...

401
01:06:56,462 --> 01:07:02,342
Por isso que eu gosto desse negócio do ponto,
porque o que é complexo, o que é que não é complexo também.

402
01:07:02,342 --> 01:07:16,346
É difícil porque a complexidade, ela vai entrar quando começa a acontecer aquilo que o Anish falou.
Agora eu tenho que fazer o pagamento em parcela.

403
01:07:16,346 --> 01:07:25,286
E você, caralho, eu nunca vi pagamento em parcela.
Nunca existiu na minha vida. E no Brasil, o pagamento em parcela é feito de um jeito.

404
01:07:25,286 --> 01:07:31,846
Se você vai para outros países da América Latina,
o pagamento em parcela é feito de outro jeito.

405
01:07:31,846 --> 01:07:37,926
Então não dá nem para você dizer, eu posso reusar diretamente aquilo que é do Brasil
e o que é dos outros países do parcelamento,

406
01:07:37,926 --> 01:07:55,706
porque é outra coisa, é outra solução. Eu acho que quando a gente fala de o que é simples e o que é complexo,
onde tem, eu acho que onde está complexo, é onde você precisa de muito conhecimento,

407
01:07:55,706 --> 01:08:08,506
onde tem muita coisa sendo definida, muita regra que precisa existir ali para esse sistema funcionar,
porque você precisa manter todas essas coisas na sua cabeça.

408
01:08:08,506 --> 01:08:21,278
Como é que eu vou conseguir fazer, separar?
a implementação da decisão é simples. Porque você tem o predicado e você tem a execução que é estratégia.

409
01:08:21,278 --> 01:08:27,838
São dois padrões que a gente conhece desde que saiu da faculdade.
Todo mundo vê essas coisas desde que saiu da faculdade.

410
01:08:27,838 --> 01:08:37,758
Mas implementar as regras diretamente, definir como essas coisas vão existir
dentro do sistema maior, aí é que vem a complexidade do negócio.

411
01:08:37,758 --> 01:08:50,686
E você entender que... vai ter coisa que vai quebrar sua arquitetura, vai ter coisa que vai mudar, vai ter coisa que você vai ter que parar
po, aqui eu vou ter que rever, eu tô entrando num outro país onde as coisas são diferentes, os meios de pagamento são diferentes

412
01:08:50,686 --> 01:09:07,126
e aí você vai fazendo a coisa funcionar, é só você não entrar nesse negócio, ah, eu vou isolar tudo, vai ser perfeito, eu não vou conseguir
não vou ter mais que mudar nada, não, você vai ter que mudar coisa pra caralho, não é? Ninguém consegue acertar na primeira vez e a sua arquitetura

413
01:09:07,278 --> 01:09:16,758
você vai ter que ir lentamente evoluindo, por isso que eu gosto muito dessa ideia de arquiteturas que são evolutivas,
que elas vão evoluindo junto com a aplicação,

414
01:09:16,758 --> 01:09:22,598
porque é mais fácil você ir evoluindo com os problemas
do que você tentar entender todos os programas.

415
01:09:22,598 --> 01:09:26,838
Não sei se você já tem experiência, né? Você foi uma pessoa...
Ah, eu trabalho com pagamentos faz dez anos,

416
01:09:26,838 --> 01:09:34,158
eu botei, fiz, trabalhei com adquirência em 50 países diferentes.
Foda! Então você já provavelmente já viu muita coisa,

417
01:09:34,158 --> 01:09:40,614
você vai conseguir arquiteturar tudo, mas...
É difícil você ser essa pessoa. Na maior parte, às vezes, a gente não tem tanto conhecimento assim

418
01:09:40,614 --> 01:09:50,374
para tomar essas decisões e definir essas coisas.
Então é entender que quanto mais conhecimento você precisa

419
01:09:50,374 --> 01:09:58,054
para colocar dentro do sistema, porque eu...
Pronto, e vou dizer agora o que eu gostei da porra do livro do Bob Martin,

420
01:09:58,054 --> 01:10:08,542
que escrever soft é como se fosse um experimento científico.
Isso, isso, isso tá pronto. Aí foi uma coisa que me marcou.

421
01:10:09,342 --> 01:10:22,102
Gostei dessa definição dele ter essa visão, porque é exatamente isso mesmo.
Podia ser um tweet. É isso. Não dá para você discutir isso de uma forma mais longa dentro do livro.

422
01:10:22,102 --> 01:10:29,062
Eu acho que isso é uma parada muito válida e eu acho que é assim que a gente escreve software.
A gente vai com pequenos experimentos, construindo o conhecimento,

423
01:10:29,502 --> 01:10:36,014
construindo o entendimento do que está acontecendo ali.
E você vai sempre nesse caminho de pequenos experimentos.

424
01:10:36,014 --> 01:10:43,174
Você faz um pequeno experimento aqui, agora isso aqui está afetando outra coisa,
vai lá, melhora essa outra coisa, melhora sua arquitetura, coloca mais uma opção lá,

425
01:10:43,174 --> 01:10:51,214
e você vai lentamente fazendo o negócio crescer.
Com essa ideia de que escrever software é trabalhar com experimentos científicos.

426
01:10:52,534 --> 01:11:02,334
E, assim, alguém já leu o Building Evolutionary Architecture?
Eu acho que o Architecture the Hard Parts tem uma pegada também, né?

427
01:11:03,022 --> 01:11:16,642
dessa pelo que vocês postaram ali, parece que tem essa ideia de
sair descobrindo e mudando. Tem isso, Olinhar? Só para você comentar,

428
01:11:16,642 --> 01:11:27,482
acho que você já leu, né? Tem, tem isso. Acho que hoje não vale mais a pena ler ele não,
ele já está meio velhinho, na época valia mais a pena.

429
01:11:27,482 --> 01:11:37,870
Acho que hoje o Fundamentals of Software Architecture
e o Software Architecture... The Hard Parts, eles cobrem mais, mas eles seguem muito essa ideia.

430
01:11:37,870 --> 01:11:45,990
Quem está com tempo livre, lê o livro, vale a pena ter essa ideia,
mas esses dois livros, eles abordam também essa ideia.

431
01:11:46,790 --> 01:11:55,870
Legal. O Branas, vai lá. Não, só para fechar aqui.
Para mim, o princípio mais importante é o tal do Kiss, que é o Equipe de Simpo.

432
01:11:55,870 --> 01:12:05,902
Então, eu acho que estou muito aí com a co-prinão do Maurício.
Software é um grande experimento, sabe? Envolve em alguns casos até sorte, sabe?

433
01:12:05,902 --> 01:12:13,202
De você pegar o caminho certo pra você não ter um grande retrabalho depois.
Então, pra mim, a melhor alternativa sempre foi

434
01:12:13,202 --> 01:12:19,902
manter o software o mais simples possível e ir dando passos
pra gente conseguir manter uma boa curva de aprendizado pra equipe,

435
01:12:19,902 --> 01:12:30,790
um bom clima e ir gerenciando a dor. Pode doer por dois motivos.
E é mais comum, às vezes, até mesmo doer, porque você escolheu a, entre aspas, a arquitetura,

436
01:12:30,790 --> 01:12:38,510
ou, entre aspas, o design errado, e aquilo está te forçando numa burocracia sem fim,
do que doer pela manutenibilidade que está prejudicada.

437
01:12:38,510 --> 01:12:50,670
Às vezes também dói. Então, talvez, se você conseguir perceber essa dor no momento certo, tomar as decisões certas com coragem,
e aí pode ter um teste de integração, ali, como o Ponte citou, pode ter um teste de two-hand,

438
01:12:50,670 --> 01:12:59,930
o teste só para aí pode ter coragem. Se você tem a coragem necessária.
e o teste te garante isso. Para você tomar a ação na hora certa e na hora que precisa,

439
01:12:59,930 --> 01:13:07,770
você mitiga muito achismo e muita coisa que você talvez não vá precisar
e assim você consegue estabelecer a melhor experiência possível

440
01:13:07,770 --> 01:13:14,810
para as pessoas que estão trabalhando e o melhor fluxo de valor de negócio para o cliente final.
Então, para mim, o melhor caminho segue sendo esse.

441
01:13:14,810 --> 01:13:21,070
Às vezes a gente está discutindo uma coisa muito específica,
falando de DDD, falando de clean arc, mas dando uns passos atrás,

442
01:13:21,070 --> 01:13:28,270
eu acho que o que vale muito é essa postura.
de humildade frente ao problema que você não conhece, e aí você ter a capacidade

443
01:13:28,270 --> 01:13:34,670
de, ao longo do trajeto, ter coragem para tomar as ações.
Para mim, esse é o ponto.

444
01:13:38,286 --> 01:13:49,046
Boa. Perfeito, muito bem colocado, Uranus. É isso.
Pessoal, vamos encerrando assim, vamos fazer uma rodada de tipo...

445
01:13:49,046 --> 01:13:58,406
Estava pensando assim, fazer uma... Cleanar que morreu, e aí?
Sim ou não? Mas não é uma pergunta que faça sentido, né?

446
01:13:58,406 --> 01:14:09,206
Então, pode ter considerações finais. Tá bem?
Eu queria abrir a palavra para muita gente que está aqui que eu admiro e tal,

447
01:14:09,206 --> 01:14:20,726
e muito obrigado por ter comparecido. Está bem pessoal, mas muita gente mesmo.
Mas não dá, né? Então vamos fazer essa rodada?

448
01:14:20,726 --> 01:14:30,326
Roberta, você tem alguma coisa a colocar sem considerações finais?
Você aprendeu algo aqui? Ah, sempre, sempre.

449
01:14:30,326 --> 01:14:43,278
Essas discussões são muito ricas. Eu acho que uma coisa que eu estava pensando à medida que a discussão estava se desenrolando,
que fica sempre muito na minha cabeça, é a questão de desperdício.

450
01:14:43,278 --> 01:14:55,918
Eu sou um pouco cria da época que se discutia muito, desenvolvimento, tentar evitar desperdício e tal.
E eu lembrei, quando o Luiz falou de experimento e de experimentação,

451
01:14:55,918 --> 01:15:04,926
eu lembrei de um artigo de pesquisa da área de Engenharia de Software.
trabalhei com pesquisa durante um curto espaço,

452
01:15:04,926 --> 01:15:17,606
que eu falei durante o mestrado, e era um artigo que se debruçava
sobre a quantidade de código morto nos projetos,

453
01:15:17,606 --> 01:15:28,286
quanto código a gente escreve que, no fim, ou nunca é executado, ou muito pouco é executado,
acaba não servindo para nada. E um dos exemplos que mais me marcou nesse artigo era justamente

454
01:15:28,654 --> 01:15:39,454
uma investigação em vários repositórios de código de CLIs,
de aplicações que eram CLIs, mostrando que mais de 80% dos parâmetros de configuração

455
01:15:39,714 --> 01:15:48,454
de comandos em CLIs nunca eram utilizados para os usuários de CLIs.
E isso é código, né, gente? Toda linha de código que você adiciona

456
01:15:49,934 --> 01:16:00,718
num sistema, numa aplicação, ela vem com custo, não é de graça.
Ela adiciona... Tem porque alguém vai precisar parar para ler, para entender.

457
01:16:00,718 --> 01:16:15,518
Aquela velha máxima de que o melhor código é aquele que a gente não escreve.
E eu acho que isso casa muito bem com a discussão, porque é sempre, a gente tem que sempre avaliar esse trade-off,

458
01:16:15,518 --> 01:16:24,518
do quanto a gente está complexificando o nosso código, o nosso software,
por opções e flexibilidades que a gente acabará não de fato utilizando.

459
01:16:24,518 --> 01:16:35,978
Enquanto isso... Existem concorrentes, existem outras pessoas, outros times,
outras aplicações sendo construídas que estão mais focadas em deliverables,

460
01:16:35,998 --> 01:16:46,058
em entregar software funcionando. Pelo menos a minha filosofia como desenvolvedora
sempre foi fazer a coisa mais simples que pudesse funcionar

461
01:16:46,378 --> 01:17:00,702
e adaptá-la quando e se fosse preciso adaptá-la.
Então era isso. Uau! Muito bom. Vamos lá, Linhares.

462
01:17:00,702 --> 01:17:13,542
Tem alguma consideração final? Leon, Domain Driven Design, por favor.
Para vocês verem essa discussão de uma forma mais profunda.

463
01:17:13,542 --> 01:17:24,402
Leon fundamenta o software architecture para entender o que é a arquitetura do software,
para ver os fundamentos, questões de... Os tipos de arquitetura, quais são os tipos de comunicação.

464
01:17:24,654 --> 01:17:38,054
Como a gente está produzindo aplicações hoje.
Então, a gente tem muito material. É incrível olhar a bibliografia que a gente tem de material disponível hoje

465
01:17:38,054 --> 01:17:47,114
para você entender um pouco mais sobre esse tipo de coisa.
Me perguntaram no Twitter, mas eu posso dizer que o Clean Architecture é uma merda sem ter lido?

466
01:17:47,114 --> 01:17:53,954
Não, você não pode. Se você não leu a porra do livro, você não fala do livro.
Se você não entende o que é que está lá, você não sabe por que é que é problemático.

467
01:17:54,414 --> 01:18:02,414
as ideias que estão lá dentro, então é melhor você não dizer.
É a mesma coisa que o Mini estava falando, todo mundo viu no blog que o Clean Art

468
01:18:02,414 --> 01:18:10,414
e fica falando as coisas, você pega o livro e vai ler, bicho, vai ver o que está escrito lá,
vai ver quais são as ideias que estão sendo definidas lá para você poder

469
01:18:10,414 --> 01:18:19,414
entender o que vai usar e o que não vai usar. Então a gente tem muito material,
a gente tem muita coisa que ajuda, inclusive a gente tem que agradecer,

470
01:18:19,414 --> 01:18:26,894
porque na época que eu e o Ponte, o Ponte queria...
querendo pagar de jovem aí, ele não é jovem, o Ponti tem a mesma idade.

471
01:18:26,894 --> 01:18:38,394
É velho igual a mim, né? A gente começou a trabalhar junto praticamente, né?
E nessa época a gente não tinha toda essa bibliografia, toda essa oportunidade de discutir essas coisas, né?

472
01:18:38,394 --> 01:18:47,394
Você pega um livro como o Design in Data Intensive Applications,
se a gente tivesse esse livro 15 anos atrás, a gente tinha evitado fazer muita merda que a gente escreveu, né?

473
01:18:47,394 --> 01:18:58,726
A gente fez muita merda nesses 16, 18 anos que a gente está escrevendo software.
Porque a gente tava aprendendo, né? As pessoas estavam aprendendo essas merdas e estão escrevendo os livros e mostrando

474
01:18:58,726 --> 01:19:07,326
Olha, olha todas as merdas que a gente fez, aprenda a não fazer essas merdas
Então peguem esse material, leiam também o livro do Aquiles

475
01:19:07,326 --> 01:19:15,486
Vamos estudar um pouquinho mais, vamos entender um pouquinho mais
Pra gente escrever software melhor pra hoje e pro futuro

476
01:19:15,486 --> 01:19:24,070
Porque no fim das contas é você que vai se rasgar dando manutenção a essa merda que você produziu hoje
Então... E o jeito ou de outro, a gente que vai ter que pagar essa conta.

477
01:19:24,070 --> 01:19:34,230
Então vamos fazer um pouquinho melhor para a gente não ter tanta dor de cabeça aí no longo prazo.
Duas lições então. Roberto falou que o nosso código 80% é inútil

478
01:19:34,230 --> 01:19:43,310
e que o Mauricio falou que... Que isso? Eu falei isso não.
Estou brincando. Estou fazendo factoid aqui.

479
01:19:43,310 --> 01:19:53,318
E o Mauricio falou que a gente vai sofrer com o código que a gente mesmo produz.
Essa segunda aí realmente é isso mesmo, né pessoal?

480
01:19:53,318 --> 01:20:04,718
Branas, considerações finais? Considerações finais é basicamente agradecer a todos aí, obrigado.
Acho que a discussão é sempre muito válida.

481
01:20:04,718 --> 01:20:15,318
Minha, sigam o conselho do Keep It Simple. No fim das contas o legado vai ser teu, a dor vai ser tua.
Então aprenda a lidar com ela, da melhor forma possível.

482
01:20:15,318 --> 01:20:28,190
E tenta sempre... um passo a frente, nem que seja pra não usar. Vale muito o conselho que o Mauricio colocou.
Cara, você pode estudar Domain Driven Design, nem que seja pra dizer, aqui não se aplica.

483
01:20:28,190 --> 01:20:37,510
Mas pelo menos você tira esse peso do teu coração e tira essa síndrome, às vezes,
de estar pegando o caminho errado. Na maior parte das vezes o caminho simples é o melhor.

484
01:20:37,510 --> 01:20:50,802
Um pouco do que o Ponte falou ali, eu concordo. Uma parte das vezes o simples e o direto...
vai atender, vai resolver e vai ser a melhor saída e o teste de integração vai ser o mais assertivo.

485
01:20:50,802 --> 01:21:02,502
Então, keep it simple, esteja sempre um passo à frente, nem que seja para saber que você não precisou daquilo.
E o seu curso, como é que eu pego o Brantz? Fala aí.

486
01:21:02,502 --> 01:21:13,582
A gente está na turma número 8, o meu curso basicamente ele reúne desde o refactoring, o test driven development...
entrando em portos em adapters, discutindo com arquitectos,

487
01:21:13,602 --> 01:21:24,642
entrando em DDD, Solids, Design Patterns, CTRS,
e muito nesse viés, tá? Assim, é aonde você talvez precise usar isso e como você faria.

488
01:21:24,662 --> 01:21:30,482
Mas muito para trazer essa clareza para as pessoas, né?
Então a gente vai desde a escrita de código

489
01:21:30,502 --> 01:21:36,282
até a estruturação disso, seja em microserviços, né?
Então é só entrar aí no meu canal no YouTube,

490
01:21:36,302 --> 01:21:47,594
você vai encontrar bastante informação. Boa.
Valeu! Aniche, vamos lá? Considerações finais e fala do seu livro também.

491
01:21:47,594 --> 01:21:59,630
Eu comprei, muito bom! Eu não vou fazer trabalho aqui não, Alexandre.
Mas o que eu ia falar, eu acho que esse livro é muito mais sobre design do que arquitetura, né?

492
01:21:59,630 --> 01:22:12,670
É muito mais sobre como organizar classes e criar código flexível, etc. e tal.
E bem menos de arquitetura, né? E o Dredé é um livro muito legal quando se fala de design, mas acho que o que me influenciou de verdade

493
01:22:12,670 --> 01:22:20,670
foi o Growing Object-Ariented Systems Guided By Tests.
E quando eu vi a pegada dos dois autores ali, em como eles programam, em como eles deixam...

494
01:22:21,422 --> 01:22:26,982
as abstrações emergirem, acho que me influenciou bastante.
É um livro que a gente fala bem pouco, né?

495
01:22:26,982 --> 01:22:36,342
Porque o C-Free Man e Night Price não são tão populares aí na comunidade,
mas é um livro bem bom. Doe um pouco ler porque um monte de código em swing ali que ninguém gosta mais, né?

496
01:22:36,342 --> 01:22:46,782
Três páginas pra colocar um botão na tela, mas a ideia ali de como eles programam é bem legal, me influenciou bastante.
Então fica aí essa recomendação. E boa noite aí, gente.

497
01:22:47,374 --> 01:23:01,054
Inclusive, Aniche, esse livro chega a uma arquitetura hexagonal.
A gente pode dizer que chega nesse ponto. Eu acho que eles não usam o termo port-sen adapters no livro, boa pergunta,

498
01:23:01,054 --> 01:23:09,214
mas eles têm bastante discussões sobre como modelar classes que são flexíveis,
como fazer com que partes dos sistemas sejam fáceis de serem trocadas, etc.

499
01:23:09,214 --> 01:23:22,102
Mas acho que eles são um pouco mais pragmáticos na discussão deles.
Sim, sim. O Ponte, vamos lá, considerações finais.

500
01:23:22,102 --> 01:23:33,102
Eita, não vou falar sobre o livro porque eu não leio o livro do Klyn Arcta.
Então é mais para deixar aqui uma reflexão que eu tenho, do tipo, da minha carreira,

501
01:23:33,102 --> 01:23:43,542
que é o cuidado de ser dogmático ou pragmático.
Eu já fui, no início da minha carreira, ali, jovem, sem muito entendimento do mundo, do mercado,

502
01:23:43,542 --> 01:23:56,190
já fui dogmático, já segui... Anko Bob, já segui Domain Driven Design ali a pé da letra
e vi que só é dois sofrimentos, tá? Então eu tento balancear isso com um pouco mais de pragmatismo, né?

503
01:23:56,230 --> 01:24:02,950
E um dos... Nos pilares do pragmatismo é que eu uso é
don't fight of frameworks, né? Não brigue com seus frameworks, né?

504
01:24:02,990 --> 01:24:09,550
Já dizia Mark Fallow em seu livro de 2002, já dizia
Eric Ivans em seu livro de 2004, não brigue com seus frameworks, né?

505
01:24:09,590 --> 01:24:15,390
E hoje não há qualquer motivo de eu brigar com meu Reis,
ou brigar com meu Laravel, ou eu brigar aqui com meu Spring Boot, né?

506
01:24:15,694 --> 01:24:20,614
porque a gente está fazendo mais de 80% do trabalho sujo.
Eu só tenho que me preocupar com a reira de negócio,

507
01:24:20,614 --> 01:24:27,894
e é isso que a gente tenta fazer há mais de 20 anos,
deixar o desenvolvedor, a desenvolvedora, só se preocupar com a reira de negócio.

508
01:24:27,894 --> 01:24:33,774
Mas quando está simples ter de hoje, a gente gosta de complicar.
Então eu não sei se vale, talvez no início da sua carreira,

509
01:24:33,774 --> 01:24:44,014
investir tanto em estilos arquiteturais. Não é que você não vai estudar fundamentos, orientação a objeto,
ou um paradigma funcional, ou mesmo só de alguns padrões de projeto.

510
01:24:44,302 --> 01:24:53,062
Só acho que talvez não vale tanta pena você investir nessa briga dogmática
de estilos arquiteturais hexagonal, clean ou qualquer outro,

511
01:24:53,102 --> 01:25:02,422
quando boa parte do seu trabalho vai ser usar um framework.
Então domine aquele framework, tá bom? Então acho que deixo essa sessão com isso.

512
01:25:04,558 --> 01:25:20,118
Perfeito. Aprendam seu framework. Não tem, tem, porque o framework não é um detalhe.
Otávio, ou o framework é um detalhe? Brincadeira. Considerações sinais, Otávio?

513
01:25:20,118 --> 01:25:30,898
Pô, pessoal, obrigado. Nossa, achei bem legal a discussão.
E isso, né? Eu sou entusiasta do estudo, sou professor universitário.

514
01:25:31,374 --> 01:25:49,374
Então eu fico muito feliz de ver o pessoal na linha de frente, que é deve mesmo, recomendando que se leia mais livros, que o pessoal estude mesmo, acho que vale a pena esse tipo de recomendação.
Porque é como o Brana se falou, mesmo que seja pra você saber onde não usar certas coisas.

515
01:25:49,374 --> 01:26:05,502
Então só esse recado final mesmo, acho que vale a pena a gente se aprofundar nas coisas, porque senão você acaba sendo um...
viram uma espécie de robô fazendo as coisas sem pensar, sem saber exatamente o que está fazendo.

516
01:26:05,502 --> 01:26:13,162
Então acho legal essa profundidade de a gente pegar esses livros.
Eu gosto muito do livro que o Anish recomendou também.

517
01:26:13,162 --> 01:26:18,542
E de fato, não, ele não pode ser na Adeptors mesmo.
Acho que foi um dos primeiros livros que fala...

518
01:26:18,542 --> 01:26:33,706
Não sei se ele fala o termo, mas no próprio Clean Architecture ele fala desse livro como se fosse um dos primeiros a...
utilizar esse tipo de estilo arquiteto. Eu lembro que chega em um parecido mesmo.

519
01:26:33,706 --> 01:26:49,466
Esse Growing Objects Guided by Tests, eu segui o exemplo, sabe?
Eu fiz, lá deu um trabalho caramba. Mas foi bem legal. E eles chegam em algo parecido, né, Otávio?

520
01:26:50,466 --> 01:27:01,962
Sim, é isso mesmo. E o livro é espetacular, né? Apesar de eu ser mais...
gostar mais do estilo de TDD mais clássico, do estilo do Kent Beck mesmo, mas...

521
01:27:01,962 --> 01:27:12,862
Então é isso, né? Acho que é legal a gente conhecer todos os tipos, estilos de programação,
de desenvolvimento, TDD, etc. E saber isso também tem, vai ter esses temas.

522
01:27:12,862 --> 01:27:23,794
Também assim, tem muito, a cultura é muito diversa, dependendo da empresa que você tá,
né? A empresa tá fechada com o framework, né? Então, por exemplo, eu tenho amigos, eu tenho um...

523
01:27:24,462 --> 01:27:34,462
o Tony, que é meu amigão, que é principal engineer da Boozer, né?
A Boozer, ela é feita em cima do Django, né?

524
01:27:34,462 --> 01:27:42,662
Então assim, tem problema isso? Não tem problema, né?
Funciona muito bem o aplicativo. Claro, você fechou com o framework, né?

525
01:27:42,662 --> 01:27:55,734
Pode ser que tenha algum risco nisso. Quer dizer, o framework pode ser que seja menos estável do que a linguagem.
Então você está dependendo de uma coisa que talvez seja menos estável, mas é um trade-off,

526
01:27:55,734 --> 01:28:09,014
sempre tem esses trade-offs na vida. Então acho que vale a pena, só queria deixar esse recado final,
que o pessoal se aprofundar mesmo, estudar, através de livros que realmente aprofundam esses temas,

527
01:28:09,014 --> 01:28:20,454
para não fazer as coisas de qualquer jeito nas coxas e fazer cada vez melhor,
como o Linhares falou, você que vai ter que cuidar do legado depois.

528
01:28:20,910 --> 01:28:32,210
Valeu, galera. Pois é. E o Otávio tem um livro aí muito bom.
Eu estou lendo. E é sucinto, mas consegue ser mais ponderado do que o...

529
01:28:32,230 --> 01:28:40,030
O livro do Ankombago tem 400 páginas. É impressionante.
E o termo Portion Adapters aparece mesmo no livro, Alexandre.

530
01:28:40,050 --> 01:29:00,326
Tocou ele aberto aqui. Ah, legal. Legal. E então é isso, pessoal.
Aí... A gente não falou um monte de coisas que a gente abordou na thread lá, tipo o que é design, o que é arquitetura.

531
01:29:00,326 --> 01:29:13,166
E o Otávio só chegou a mencionar a Functional Core Imperative Shell. Tem tanta coisa interessante assim, né?
Mas é isso. Senão a gente vai ficar aqui para sempre conversando, né?

532
01:29:13,166 --> 01:29:26,398
Mas muito obrigado. Desculpa aí o Hugo, o Juan Lopes, a Glace.
o Rinaldo e várias outras pessoas aí que eu não consegui dar a palavra, né, porque senão...

533
01:29:26,398 --> 01:29:39,278
que estão aparecendo aqui. E várias outras que eu não vou mencionar porque senão eu vou ficar falando
aqui pra sempre. Mas muito obrigado por comparecer aí, pessoal. Eu vou ter que ouvir isso 15 vezes

534
01:29:39,278 --> 01:29:51,534
pra absorver todo o conhecimento aqui. Então muito obrigado e eu vou finalizar aqui então. Beleza?
Tchau, tchau pessoal! Valeu!

